import * as Net from 'net';
import * as _ from 'lodash';
import { getProperIP } from 'dimensions/utils';
import Client from 'dimensions/client';
import ClientArgs from 'dimensions/clientargs';
import ServerDetails from 'dimensions/serverdetails';
import GlobalHandlers from 'dimensions/globalhandlers';
import { ConfigServer, ConfigOptions } from 'dimensions/configloader';
import RoutingServer from 'dimensions/routingserver';
import Blacklist from 'dimensions/blacklist';
import PacketTypes from 'dimensions/packettypes';
import PacketWriter from 'dimensions/packets/packetwriter';
import PacketReader from 'dimensions/packets/packetreader';
import GlobalTracking from 'dimensions/globaltracking';
import Logger from 'dimensions/logger';
import ListenServerArgs from 'dimensions/listenserverargs';

/**
 * Listens on a specified port and routes users balancing amounts between routing servers it handles
 */
export class ListenServer {
  idCounter: number;
  clients: Client[];
  servers: { [id: string]: RoutingServer };
  options: ConfigOptions;
  port: number;
  routingServers: RoutingServer[];
  serversDetails: { [id: string]: ServerDetails };
  globalHandlers: GlobalHandlers;
  ServerHandleError: (error: Error) => void;
  ServerHandleSocket: (socket: Net.Socket) => void;
  ServerHandleStart: () => void;
  server: Net.Server;
  globalTracking: GlobalTracking;
  logging: Logger;
  blacklist: Blacklist;

  constructor(args: ListenServerArgs) {
    this.idCounter = 0;
    this.clients = [];
    this.servers = args.servers;
    this.options = args.options;
    this.port = args.info.listenPort;
    this.routingServers = args.info.routingServers;
    this.serversDetails = args.serversDetails;
    this.globalHandlers = args.globalHandlers;
    this.globalTracking = args.globalTracking;
    this.logging = args.logging;
    this.blacklist = args.blacklist;

    for (var i = 0; i < this.routingServers.length; i++) {
      this.serversDetails[this.routingServers[i].name] = {
        clientCount: 0,
        disabled: false,
        disabledTimeout: null,
        failedConnAttempts: 0
      };
    }


    this.ServerHandleError = this.handleError.bind(this);
    this.ServerHandleStart = this.handleStart.bind(this);

    // Listen Server
    this.server = Net.createServer();
    this.server.on('connection', (socket) => {
      this.handleSocket(socket)
        .catch((e) => {
          if (this.options.log.clientError) {
            if (this.options.log.outputToConsole) {
              console.log(`Socket Error: ${e}`);
            }
            this.logging.appendLine(e);
          }
        });
    });
    this.server.listen(this.port, this.ServerHandleStart);
    this.server.on('error', this.ServerHandleError);
  }

  /**
   * Finds server with lowest client count
   * 
   * @return Either a found routing server or null if one was not found
   */
  chooseServer(): RoutingServer | null {
    let chosenServer: RoutingServer | null = null;
    let currentClientCount: number | null = null;
    let details: ServerDetails;
    for (let i: number = 0; i < this.routingServers.length; i++) {
      details = this.serversDetails[this.routingServers[i].name];

      // Even if the server has been disabled, if we have no current choice, we must use it
      if (!details.disabled || currentClientCount === null) {
        // Favour either lower player count or non-disability
        if (currentClientCount === null || chosenServer === null || details.clientCount < currentClientCount || this.serversDetails[chosenServer.name].disabled) {
          chosenServer = this.routingServers[i];
          currentClientCount = details.clientCount;
        }
      }
    }

    return chosenServer;
  }

  /**
   * Updates this listen server with its new ownership of routing servers
   * 
   * @param info The server configuration containing the routing servers for this listen server
   */
  updateInfo(info: ConfigServer): void {
    this.port = info.listenPort;
    this.routingServers = info.routingServers;

    // Reset disabled and failedConnAttempts but only
    // reset counts if it didn't already exist as a server
    let details;
    for (let i = 0; i < this.routingServers.length; i++) {
      if (this.serversDetails[this.routingServers[i].name]) {
        details = this.serversDetails[this.routingServers[i].name]
        details.disabled = false;
        details.failedConnAttempts = 0;
      } else {
        this.serversDetails[this.routingServers[i].name] = {
          clientCount: 0,
          disabled: false,
          disabledTimeout: null,
          failedConnAttempts: 0
        };
      }
    }
  }

  /**
   * Destroys all client sockets connected, removing any listeners and resets counts for any servers
   */
  shutdown(): void {
    if (this.options.log.outputToConsole) {
      console.log(`\u001b[33m[${process.pid}] Server on ${this.port} is now shutting down.\u001b[0m`);
    }

    this.logging.appendLine(`[${process.pid}] Server on ${this.port} is now shutting down.`);
    for (let i: number = 0; i < this.clients.length; i++) {
      this.clients[i].server.socket.removeListener('data', this.clients[i].ServerHandleData);
      this.clients[i].server.socket.removeListener('error', this.clients[i].ServerHandleError);
      this.clients[i].server.socket.removeListener('close', this.clients[i].ServerHandleClose);
      this.clients[i].handleClose = function () { };
      this.clients[i].socket.destroy();
    }
    this.clients = [];
    this.server.removeListener('error', this.ServerHandleError);
    this.server.close();

    // Reset counts
    let details: ServerDetails;
    for (var i = 0; i < this.routingServers.length; i++) {
      details = this.serversDetails[this.routingServers[i].name];
      details.clientCount = 0;
    }
  }

  /**
   * Logs that the server was started
   */
  handleStart(): void {
    if (this.options.log.outputToConsole) {
      console.log(`\u001b[32m[${process.pid}] Server on ${this.port} started.\u001b[0m`);
    }

    this.logging.appendLine(`[${process.pid}] Server on ${this.port} started.`);
  }

  /** 
   * Gets a server to connect to for a new socket connection, sets up the appropriate handlers
   * and checks if their IP is blacklisted
   * 
   * @param socket The socket of a new client
   */
  async handleSocket(socket: Net.Socket) {
    this.setupNewSocket(socket);
  }

  /**
   * Checks there is a server available and then sets up listeners and a client object for
   * the socket. Also checking if the ip address of this socket is blacklisted.
   */
  async setupNewSocket(socket: Net.Socket): Promise<void> {
    let i = 0;
    let chosenServer: RoutingServer | null = this.chooseServer();
    if (chosenServer === null) {
      if (this.options.log.outputToConsole) {
        console.log(`No servers available for ListenServer[Port: ${this.port}]`)
      }

      this.logging.appendLine(`No servers available for ListenServer[Port: ${this.port}]`);
      socket.destroy();
      return;
    }

    // Try using no delay (no buffering of data); maybe set to config option
    if (this.options.socketNoDelay) {
      socket.setNoDelay(true);
    }

    let clientArgs: ClientArgs = {
      id: this.idCounter++,
      socket: socket,
      server: chosenServer,
      serversDetails: this.serversDetails,
      globalHandlers: this.globalHandlers,
      servers: this.servers,
      options: this.options,
      globalTracking: this.globalTracking,
      logging: this.logging
    };

    let client = new Client(clientArgs);
    this.clients.push(client);

    if (this.options.log.clientConnect) {
      if (this.options.log.outputToConsole) {
        console.log(`[${process.pid} Client: ${getProperIP(socket.remoteAddress)} connected [${chosenServer.name}: ${this.serversDetails[chosenServer.name].clientCount + 1}]`);
      }

      this.logging.appendLine(`[${process.pid} Client: ${getProperIP(socket.remoteAddress)} connected [${chosenServer.name}: ${this.serversDetails[chosenServer.name].clientCount + 1}]`);
    }

    this.hookSocketError(socket, client);
    this.hookSocketTimeout(socket, client);
    this.hookSocketClose(socket, client);

    // Check blacklist if enabled before parsing any data and thus connecting to a server
    if (this.options.blacklist.enabled) {
      await this.checkBlackList(socket);
    }
    
    this.hookSocketData(socket, client);
  }

  /**
   * Checks the blacklist to see if the ip is blacklisted, and will disconnect the socket if they are
   * 
   * @param socket The socket to check the ip of against the blacklist
   * @return Whether or not the ip is blacklisted
   */
  async checkBlackList(socket: Net.Socket): Promise<boolean> {
    let blocked = false;
    try {
      this.sendCheckingIp(socket);

      // Get blocked status
      blocked = await this.blacklist.checkIP(getProperIP(socket.remoteAddress), this.options.blacklist.apiKey);
      if (blocked) {
        let kickPacket: string = (new PacketWriter())
          .setType(PacketTypes.Disconnect)
          .packString("Connecting using a Host Provider is not allowed.")
          .data;
        socket.write(new Buffer(kickPacket, 'hex'));

        // Allow time for client to receive and process kick packet
        setTimeout(() => {
          socket.destroy();
        }, 1000);

        if (this.options.log.clientBlocked) {
          if (this.options.log.outputToConsole) {
            console.log(`${process.pid}] Client: ${getProperIP(socket.remoteAddress)} was blocked from joining.`);
          }

          this.logging.appendLine(`${process.pid}] Client: ${getProperIP(socket.remoteAddress)} was blocked from joining.`);
        }
      }
    } catch (e) {
      if (this.options.log.outputToConsole) {
        console.log("Blacklist check failed: ");
        console.log(e);
      }

      this.logging.appendLine("Blacklist check failed: ");
      this.logging.appendLine(e);
    }

    return blocked;
  }

  /**
   * Tells the client that its IP is being checked
   * 
   * @param socket The socket of the client whose IP is being checked
   */
  sendCheckingIp(socket: Net.Socket): void {
    let statusPacket: string = (new PacketWriter())
      .setType(PacketTypes.Status)
      .packInt32(1)
      .packString("Checking IP... ")
      .data;

    socket.write(new Buffer(statusPacket, 'hex'));
  }

  /**
   * Hook the socket error and pass it into the client object
   * 
   * @param socket The socket of the client to listen for errors on
   * @param client The client object associated with the socket
   */
  hookSocketError(socket: Net.Socket, client: Client): void {
    socket.once('error', (e: Error) => {
      try {
        client.handleError(e);
      } catch (error) {
        if (this.options.log.clientError) {
          if (this.options.log.outputToConsole) {
            console.log(`handleError ERROR: ${e}`);
          }

          this.logging.appendLine(`handleError Error: ${e}`)
        }
      }
    });
  }

  /**
   *  Simply destroys any sockets that have triggered the timeout
   * 
   * @param socket The socket of the client to listen for timeouts on
   * @param client The client object associated with the socket
   */
  hookSocketTimeout(socket: Net.Socket, client: Client): void {
    socket.once('timeout', () => {
      if (this.options.log.clientTimeouts) {
        if (this.options.log.outputToConsole) {
          console.log(`Socket Timeout: ${client.getName()} ${client.ID}`);
        }

        this.logging.appendLine(`Socket Timeout: ${client.getName()} ${client.ID}`);
      }
      socket.destroy();
    });
  }

  /**
   * Hook the socket close and pass it into the client object
   * 
   * @param socket The socket of the client to listen for closing on
   * @param client The client object associated with the socket
   */
  hookSocketClose(socket: Net.Socket, client: Client): void {
    socket.once('close', () => {
      try {
        if (this.options.log.clientDisconnect) {
          if (this.options.log.outputToConsole) {
            console.log(`[${process.pid}] Client: ${getProperIP(socket.remoteAddress)} disconnected ${client.server.name}: ${this.serversDetails[client.server.name].clientCount - 1}]`);
          }

          this.logging.appendLine(`[${process.pid}] Client: ${getProperIP(socket.remoteAddress)} disconnected ${client.server.name}: ${this.serversDetails[client.server.name].clientCount - 1}]`);
        }
        client.handleClose();
        for (let i: number = 0; i < this.clients.length; i++) {
          if (this.clients[i].ID === client.ID) {
            this.clients.splice(i, 1);
            break;
          }
        }
      } catch (e) {
        if (this.options.log.clientError) {
          if (this.options.log.outputToConsole) {
            console.log(`SocketCloseEvent ERROR: ${e}`);
          }

          this.logging.appendLine(`SocketCloseEvent ERROR: ${e}`);
        }
      }

      socket.removeAllListeners();
    });
  }

  /**
   * Hook the socket data and pass it into the client object
   * 
   * @param socket The socket of the client to listen for data on
   * @param client The client object associated with the socket
   */
  hookSocketData(socket: Net.Socket, client: Client): void {
    socket.on('data', (data: Buffer) => {
      try {
        client.handleDataSend(data);
      } catch (e) {
        if (this.options.log.clientError) {
          if (this.options.log.outputToConsole) {
            console.log(`HandleDataSend ERROR: ${e}`);
          }

          this.logging.appendLine(`HandleDataSend ERROR: ${e}`);
        }
      }
    });

    socket.setTimeout(this.options.socketTimeout);
  }

  /**
   * Handles when an error event occurs for this listen server
   * 
   * @param error The error object containing the error information
   */
  handleError(error: Error) {
    if (this.options.log.outputToConsole) {
      console.log(`\u001b[31m Server on ${this.port} encountered an error: ${error}.\u001b[0m`);
    }

    this.logging.appendLine(`Server on ${this.port} encountered an error: ${error}.`);
  }
}

export default ListenServer;
