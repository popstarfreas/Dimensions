import Client from "dimensions/client";
import PacketWriter from "dimensions/packets/packetwriter";
import PacketTypes from "dimensions/packettypes";

import * as PlayerActive from "rescript-terrariapacket/src/packet/Packet_PlayerActive.gen";
import * as NpcUpdate from "rescript-terrariapacket/src/packet/Packet_NpcUpdate.gen";
import * as ItemDropUpdate from "rescript-terrariapacket/src/packet/Packet_ItemDropUpdate.gen";

class ClearUtils {
  public static clearPlayers(client: Client): void {
    const playerIDs: string[] = Object.keys(client.server.entityTracking.players);
    for (var i = 0, len = playerIDs.length; i < len; i++) {
      if (parseInt(playerIDs[i]) === client.player.id)
        continue;

      ClearUtils.clearPlayer(client, parseInt(playerIDs[i]));
    }
  }

  public static clearPlayer(client: Client, playerIndex: number): void {
    const data = PlayerActive.toBuffer({ playerId: playerIndex, active: false });
    const playerActive = { packetType: PacketTypes.PlayerActive, data };
    const playerActivePacket = client.server.getPacketHandler().handlePacket(client.server, playerActive);
    if (playerActivePacket !== null) {
      client.socket.write(playerActivePacket);
    }
  }

  public static clearNPCs(client: Client): void {
    for (const npc of client.server.entityTracking.NPCs) {
      if (typeof npc !== "undefined") {
        ClearUtils.clearNPC(client, npc.index);
      }
    }
  }

  public static clearNPC(client: Client, npcIndex: number): void {
    const data = NpcUpdate.toBuffer({
      npcSlotId: npcIndex,
      npcTypeId: 0,
      x: 0,
      y: 0,
      vx: 0,
      vy: 0,
      target: 0,
      directionX: false,
      directionY: false,
      ai: [undefined, undefined, undefined, undefined],
      spriteDirection: false,
      life: {
        tag: "Byte",
        value: 0
      },
      releaseOwner: undefined,
      playerCountScale: undefined,
      strengthMultiplier: undefined,
      spawnedFromStatue: false
    });
    const packet = { packetType: PacketTypes.NPCUpdate, data };
    const finalPacket = client.server.getPacketHandler().handlePacket(client.server, packet);
    if (finalPacket !== null) {
      client.socket.write(packet.data);
    }
    client.server.entityTracking.NPCs[npcIndex] = undefined;
  }

  public static clearItems(client: Client): void {
    for (const item of client.server.entityTracking.items) {
      if (typeof item !== "undefined") {
        ClearUtils.clearItem(client, item.slot);
      }
    }
  }

  public static clearItem(client: Client, itemIndex: number): void {
    const data = ItemDropUpdate.toBuffer({
      itemDropId: itemIndex,
      x: 0,
      y: 0,
      vx: 0,
      vy: 0,
      stack: 0,
      prefix: 0,
      noDelay: 0,
      itemId: 0
    });
    const updateItemDrop = {
      data,
      packetType: PacketTypes.UpdateItemDrop,
    };
    const updateItemDropPacket = client.server.getPacketHandler().handlePacket(client.server, updateItemDrop);
    if (updateItemDropPacket !== null) {
      client.socket.write(updateItemDropPacket);
    }
  }
}

export default ClearUtils;
