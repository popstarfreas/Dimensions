import PacketTypes from 'dimensions/packettypes';
import PacketWriter from 'dimensions/packets/packetwriter';
import PacketReader from 'dimensions/packets/packetreader';
import NPC from 'dimensions/npc';
import Item from 'dimensions/item';
import Client from 'dimensions/client';
import RawPacket from 'dimensions/packets/rawpacket';
import { Command } from 'dimensions/clientcommandhandler';
import ClientState from 'dimensions/clientstate';

import * as ConnectRequest from "rescript-terrariapacket/src/packet/Packet_ConnectRequest.gen";
import * as PlayerInfo from "rescript-terrariapacket/src/packet/Packet_PlayerInfo.gen";
import * as PlayerBuffsSet from "rescript-terrariapacket/src/packet/Packet_PlayerBuffsSet.gen";
import * as PlayerBuffAdd from "rescript-terrariapacket/src/packet/Packet_PlayerBuffAdd.gen";
import * as PlayerInventorySlot from "rescript-terrariapacket/src/packet/Packet_PlayerInventorySlot.gen";
import * as PlayerMana from "rescript-terrariapacket/src/packet/Packet_PlayerMana.gen";
import * as PlayerHealth from "rescript-terrariapacket/src/packet/Packet_PlayerHealth.gen";
import * as PlayerUpdate from "rescript-terrariapacket/src/packet/Packet_PlayerUpdate.gen";
import * as ClientUuid from "rescript-terrariapacket/src/packet/Packet_ClientUuid.gen";


class ClientPacketHandler {
  private currentClient!: Client;

  /* Checks whether the packet was handled by extensions prior to being processed by this class */
  private runPriorHandlers(client: Client, packet: RawPacket): boolean {
    let handlers = client.globalHandlers.extensions;
    let handled = false;
    for (let key in handlers) {
      let handler = handlers[key];
      if (typeof handler.priorPacketHandlers !== 'undefined' && typeof handler.priorPacketHandlers.clientHandler !== 'undefined') {
        handled = handler.priorPacketHandlers.clientHandler.handlePacket(client, packet);
        if (handled) {
          break;
        }
      }
    }

    return handled;
  }

  /* Checks whether the packet was handled by extensions after being processed by this class */
  private runPostHandlers(client: Client, packet: RawPacket): boolean {
    let handlers = client.globalHandlers.extensions;
    let handled = false;
    for (let key in handlers) {
      let handler = handlers[key];
      if (typeof handler.postPacketHandlers !== 'undefined' && typeof handler.postPacketHandlers.clientHandler !== 'undefined') {
        handled = handler.postPacketHandlers.clientHandler.handlePacket(client, packet);
        if (handled) {
          break;
        }
      }
    }

    return handled;
  }

  /* Runs the packet through extension handlers and runs any appropriate handlers of this class */
  public handlePacket(client: Client, rawPacket: RawPacket): Buffer | null {
    let priorHandled: boolean = this.runPriorHandlers(client, rawPacket);
    if (priorHandled) {
      return null;
    }

    let packetType: number = rawPacket.packetType;
    let handled: boolean = false;

    // Set current client while we handle this packet
    this.currentClient = client;
    switch (packetType) {
      case PacketTypes.ConnectRequest:
        handled = this.handleConnectRequest(rawPacket);
        break;

      case PacketTypes.PlayerInfo:
        handled = this.handlePlayerInfo(rawPacket);
        break;

      case PacketTypes.UpdatePlayerBuff:
        handled = this.handleUpdatePlayerBuff(rawPacket);
        break;

      case PacketTypes.AddPlayerBuff:
        handled = this.handleAddPlayerBuff(rawPacket);
        break;

      case PacketTypes.PlayerInventorySlot:
        handled = this.handlePlayerInventorySlot(rawPacket);
        break;

      case PacketTypes.PlayerMana:
        handled = this.handlePlayerMana(rawPacket);
        break;

      case PacketTypes.PlayerHP:
        handled = this.handlePlayerHP(rawPacket);
        break;

      case PacketTypes.UpdatePlayer:
        handled = this.handleUpdatePlayer(rawPacket);
        break;

      case PacketTypes.UpdateItemDrop:
        handled = this.handleUpdateItemDrop(rawPacket);
        break;

      case PacketTypes.UpdateItemOwner:
        handled = this.handleUpdateItemOwner(rawPacket);
        break;

      case PacketTypes.ContinueConnecting2:
        if (this.currentClient.state === ClientState.FreshConnection) {
          // Finished sending inventory
          this.currentClient.state = ClientState.FinishinedSendingInventory;
        }
        break;

      case PacketTypes.SpawnPlayer:
        handled = this.handleSpawnPlayer(rawPacket);
        break;

      case PacketTypes.LoadNetModule:
        handled = this.handleLoadNetModule(rawPacket);
        break;

      case PacketTypes.DimensionsUpdate:
        // Client cannot send 67 (It's used by Dimensions to communicate special info)
        handled = true;
        break;

      case PacketTypes.ClientUUID:
        handled = this.handleClientUUID(rawPacket);
        break;

      case PacketTypes.SetPlayerStealth:
      case PacketTypes.PlayerHurtV2:
      case PacketTypes.PlayerZone:
        handled = this.handlePotentialEarlyPacket(rawPacket);
        break;
    }

    if (handled) {
      return null;
    }

    let postHandled: boolean = this.runPostHandlers(client, rawPacket);
    if (postHandled) {
      return null;
    }

    return rawPacket.data;
  }

  private handleConnectRequest(packet: RawPacket): boolean {
    if (this.currentClient.version === "unknown") {
      const connectRequest = ConnectRequest.parse(packet.data);
      this.currentClient.version = connectRequest?.version ?? "unknown";
    }

    return false;
  }

  /* Updates tracked visuals for player to restore them when they switch from
   * an SSC to a non-SSC server */
  private handlePlayerInfo(packet: RawPacket): boolean {
    const playerInfo = PlayerInfo.parse(packet.data);
    if (typeof playerInfo === 'undefined') {
      return true;
    }

    const player = this.currentClient.player;
    if (player.name !== playerInfo.name) {
      if (player.allowedNameChange) {
        this.currentClient.setName(playerInfo.name);
      } else if (this.currentClient.options.nameChanges?.mode === "rewrite") {
        const data = PlayerInfo.toBuffer({ ...playerInfo, playerId: this.currentClient.player.id, name: player.name });
        packet.data = data;
      }
    }

    if (player.allowedCharacterChange) {
      player.skinVariant = playerInfo.skinVariant;
      player.hair = playerInfo.hair;
      player.hairDye = playerInfo.hairDye;
      player.hideVisuals = playerInfo.hideVisuals;
      player.hideVisuals2 = playerInfo.hideVisuals2;
      player.hideMisc = playerInfo.hideMisc;
      player.hairColor = playerInfo.hairColor;
      player.skinColor = playerInfo.skinColor;
      player.eyeColor = playerInfo.eyeColor;
      player.shirtColor = playerInfo.shirtColor;
      player.underShirtColor = playerInfo.underShirtColor;
      player.pantsColor = playerInfo.pantsColor;
      player.shoeColor = playerInfo.shoeColor;
      player.difficulty = playerInfo.difficulty;
      player.allowedCharacterChange = false;
    }

    return false;
  }

  /* Used to prevent invisibility buff from being sent to the server
   * for used when the config is set to blockInvis = true */
  private handleUpdatePlayerBuff(packet: RawPacket): boolean {
    const playerBuffsSet = PlayerBuffsSet.parse(packet.data);
    if (typeof playerBuffsSet === 'undefined') {
      return true;
    }

    let shouldBlockInvis = false;
    const blockInvis = this.currentClient.options.blockInvis;
    switch (blockInvis) {
      case true:
        shouldBlockInvis = true;
        break;
      case false:
        break;
      default:
        shouldBlockInvis = blockInvis.enabled && blockInvis.servers.some(server => server.toLowerCase() === this.currentClient.server.name.toLowerCase())
        break;
    }

    if (shouldBlockInvis) {
      const buffs = playerBuffsSet.buffs.map((buff) => {
        if (buff === 10) {
          return 0;
        }
        return buff;
      });

      packet.data = PlayerBuffsSet.toBuffer({ playerId: this.currentClient.player.id, buffs });
    }

    // Prevent this being sent too early (causing kicked for invalid operation)
    if (this.currentClient.state !== ClientState.FullyConnected) {
      this.currentClient.packetQueue.push(packet.data);
      return true;
    }

    return false;
  }

  /* Used to prevent invisibility buff from being sent to the server
   * for used when the config is set to blockInvis = true */
  private handleAddPlayerBuff(packet: RawPacket): boolean {
    const playerBuffAdd = PlayerBuffAdd.parse(packet.data);
    if (typeof playerBuffAdd === 'undefined') {
      return true;
    }

    let shouldBlockInvis = false;
    const blockInvis = this.currentClient.options.blockInvis;
    switch (blockInvis) {
      case true:
        shouldBlockInvis = true;
        break;
      case false:
        break;
      default:
        shouldBlockInvis = blockInvis.enabled && blockInvis.servers.some(server => server.toLowerCase() === this.currentClient.server.name.toLowerCase())
        break;
    }

    if (shouldBlockInvis) {
      return playerBuffAdd.buff === 10;
    } else {
      return false;
    }
  }

  /* Tracks the players inventory slots to restore them when they switch
   * from an SSC server to a Non-SSC server */
  private handlePlayerInventorySlot(packet: RawPacket): boolean {
    if ((this.currentClient.state === ClientState.FreshConnection || this.currentClient.state === ClientState.ConnectionSwitchEstablished) && !this.currentClient.waitingCharacterRestore) {
      const playerInventorySlot = PlayerInventorySlot.parse(packet.data);
      if (typeof playerInventorySlot === 'undefined') {
        return true;
      }
      const { slot, stack, prefix, itemId } = playerInventorySlot;
      this.currentClient.player.inventory[slot] = new Item(slot, stack, prefix, itemId);
    }

    return false;
  }

  /* Tracks the player mana to restore it when they switch from an
   * SSC server to a Non-SSC server */
  private handlePlayerMana(packet: RawPacket): boolean {
    if (!this.currentClient.player.allowedManaChange)
      return false;

    const playerMana = PlayerMana.parse(packet.data);
    if (typeof playerMana === 'undefined') {
      return true;
    }
    const { mana } = playerMana;
    this.currentClient.player.mana = mana;
    this.currentClient.player.allowedManaChange = false;

    return false;
  }

  /* Tracks the player HP to restore it when they switch from an
   * SSC server to a Non-SSC server */
  private handlePlayerHP(packet: RawPacket): boolean {
    if (!this.currentClient.player.allowedLifeChange) {
      return false;
    }

    const playerHealth = PlayerHealth.parse(packet.data);
    if (typeof playerHealth === 'undefined') {
      return true;
    }

    const { health } = playerHealth;
    this.currentClient.player.life = health;
    this.currentClient.player.allowedLifeChange = false;

    // Prevent this being sent too early (causing kicked for invalid operation)
    if (this.currentClient.state !== ClientState.FullyConnected) {
      this.currentClient.packetQueue.push(packet.data);
      return true;
    }

    return false;
  }

  private handleUpdatePlayer(packet: RawPacket): boolean {
    const playerUpdate = PlayerUpdate.parse(packet.data);
    if (typeof playerUpdate === 'undefined') {
      return true;
    }

    // Prevent this being sent too early (causing kicked for invalid operation)
    if (this.currentClient.state !== ClientState.FullyConnected) {
      this.currentClient.packetQueue.push(packet.data);
      return true;
    }

    return false;
  }

  /* Prevents the player sending the item drop packet too early
   * which causes them to be kicked. It also adds it to the packet queue
   * so that it may be sent when the client has fully connected (and wont
   * get kicked for sending it) */
  private handleUpdateItemDrop(packet: RawPacket): boolean {
    // Prevent this being sent too early (causing kicked for invalid operation)
    if (this.currentClient.state !== ClientState.FullyConnected) {
      this.currentClient.packetQueue.push(packet.data);
      return true;
    }

    return false;
  }

  /* Prevents the player sending the item owner packet too early
   * which causes them to be kicked. It also adds it to the packet queue
   * so that it may be sent when the client has fully connected (and wont
   * get kicked for sending it)
   *
   * Note: This packet is important for tShock SSC to work. If this was
   *       prevented outright, SSC would be broken (inventory would be unchangable) */
  private handleUpdateItemOwner(packet: RawPacket): boolean {
    // Prevent this being sent too early (causing kicked for invalid operation)
    if (this.currentClient.state !== ClientState.FullyConnected) {
      this.currentClient.packetQueue.push(packet.data);
      return true;
    }

    return false;
  }

  private handleSpawnPlayer(packet: RawPacket): boolean {
    if (this.currentClient.state === ClientState.FinishinedSendingInventory) {
      this.currentClient.state = ClientState.FullyConnected;
    }

    return false;
  }

  /* Handles when a net module update is sent from the client (used only for chat at this time) */
  private handleLoadNetModule(packet: RawPacket): boolean {
    let handled = false;
    let reader = new PacketReader(packet.data);
    let moduleId = reader.readUInt16();

    if (moduleId === 1) {
      // ID is either Say or Emote
      let commandId = reader.readString();
      let chatMessage = reader.readString();
      handled = this.handleChatMessage(chatMessage);
    }

    return handled;
  }

  /* Handles any commands sent by the client given they start with "/" */
  private handleChatMessage(chatMessage: string): boolean {
    let handled = false;

    // If chat message is a command
    if (chatMessage.length > 1 && chatMessage.substr(0, 1) === "/") {
      let command: Command = this.currentClient.globalHandlers.command.parseCommand(chatMessage);
      handled = this.currentClient.globalHandlers.command.handle(command, this.currentClient);
    }

    return handled;
  }

  /* Updates the clients current tracked UUID */
  private handleClientUUID(packet: RawPacket): boolean {
    const clientUuid = ClientUuid.parse(packet.data);
    if (typeof clientUuid === 'undefined') {
      return true;
    }
    this.currentClient.UUID = clientUuid.uuid;

    return false;
  }

  /* Some packets should not be sent early to avoid kick for invalid operation at this state */
  private handlePotentialEarlyPacket(packet: RawPacket): boolean {
    // Prevent this being sent too early (causing kicked for invalid operation)
    if (this.currentClient.state !== ClientState.FullyConnected) {
      this.currentClient.packetQueue.push(packet.data);
      return true;
    }

    return false;
  }

}

export default ClientPacketHandler;
