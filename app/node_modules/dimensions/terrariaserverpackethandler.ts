import PacketTypes from 'dimensions/packettypes';
import NetworkText from 'dimensions/packets/networktext';
import PacketReader from 'dimensions/packets/packetreader';
import PacketWriter from 'dimensions/packets/packetwriter';
import { getProperIP, getPackedStringByteLen } from 'dimensions/utils';
import NPC from 'dimensions/npc';
import TerrariaServer from 'dimensions/terrariaserver';
import Client from 'dimensions/client';
import RawPacket from 'dimensions/packets/rawpacket';
import * as Net from 'net';
import Point from 'dimensions/point';
import Item from 'dimensions/item';
import Player from 'dimensions/player';
import ClientState from 'dimensions/clientstate';
import BitsByte from 'dimensions/datatypes/bitsbyte';
import ClearUtils from 'dimensions/clearutils';

/**
 * This handles all packets coming from a Terraria Server, sometimes responding instead of the client
 * to ensure a smooth and successful transition between servers (due to a client state prohibiting a
 * certain response)
 */
class TerrariaServerPacketHandler {
  private currentServer!: TerrariaServer;
  private socket?: Net.Socket;

  /**
   * Checks whether the packet was handled by extensions prior to being processed by this class
   *
   * @param server The server object assigned to a player that is sending a packet
   * @param packet The packet that is being sent
   * @return Whether or not the packet was handled (and should not be sent)
   */
  private runPriorHandlers(server: TerrariaServer, packet: RawPacket): boolean {
    let handlers = server.client.globalHandlers.extensions;
    let handled = false;
    for (let key in handlers) {
      let handler = handlers[key];
      if (typeof handler.priorPacketHandlers !== 'undefined' && typeof handler.priorPacketHandlers.serverHandler !== 'undefined') {
        handled = handler.priorPacketHandlers.serverHandler.handlePacket(server, packet);
        if (handled) {
          break;
        }
      }
    }

    return handled;
  }

  /**
   * Checks whether the packet was handled by extensions after being processed by this class
   *
   * @param server The server object assigned to a player that is sending a packet
   * @param packet The packet that is being sent
   * @return Whether or not the packet was handled (and should not be sent)
   */
  private runPostHandlers(server: TerrariaServer, packet: RawPacket): boolean {
    let handlers = server.client.globalHandlers.extensions;
    let handled = false;
    for (let key in handlers) {
      let handler = handlers[key];
      if (typeof handler.postPacketHandlers !== 'undefined' && typeof handler.postPacketHandlers.serverHandler !== 'undefined') {
        handled = handler.postPacketHandlers.serverHandler.handlePacket(server, packet);
        if (handled) {
          break;
        }
      }
    }

    return handled;
  }

  /**
   * Runs the packet through extension handlers and runs any appropriate handlers of this class
   *
   * @param server The server object assigned to a player that is sending a packet
   * @param packet The packet that is being sent
   * @return The packet data (either origin or modified)
   */
  public handlePacket(server: TerrariaServer, packet: RawPacket): Buffer | null {
    this.currentServer = server;

    let priorHandled: boolean = this.runPriorHandlers(server, packet);
    if (priorHandled) {
      return null;
    }

    let handled: boolean = false;
    let packetType: number = packet.packetType;

    switch (packetType) {
      case PacketTypes.Disconnect:
        handled = this.handleDisconnect(packet);
        break;

      case PacketTypes.ContinueConnecting:
        handled = this.handleContinueConnecting(packet);
        break;

      case PacketTypes.WorldInfo:
        handled = this.handleWorldInfo(packet);
        break;

      case PacketTypes.CompleteConnectionAndSpawn:
        handled = this.handleCompleteConnectionAndSpawn(packet);
        break;

      case PacketTypes.DimensionsUpdate:
        handled = this.handleDimensionsUpdate(packet);
        break;

      case PacketTypes.NPCUpdate:
        handled = this.handleNPCUpdate(packet);
        break;

      case PacketTypes.UpdateItemDrop_Instanced:
      case PacketTypes.UpdateItemDrop:
        handled = this.handleUpdateItemDrop(packet);
        break;

      case PacketTypes.PlayerActive:
        handled = this.handlePlayerActive(packet);
        break;

      case PacketTypes.PlayerInventorySlot:
        handled = this.handlePlayerInventorySlot(packet);
        break;

      case PacketTypes.PlayerInfo:
        handled = this.handlePlayerInfo(packet);
        break;

      default:
        break;
    }

    if (handled) {
      return null;
    }

    let postHandled: boolean = this.runPostHandlers(server, packet);
    if (postHandled) {
      return null;
    }

    return packet.data;
  }

  /**
   * Passes on the disconnect message as a chat message to the client, unless the client
   * has not fully connected to any Dimension yet.
   *
   * @param The disconnect packet
   * @return Whether or not this packet was handled (and should not be sent)
   */
  private handleDisconnect(packet: RawPacket): boolean {
    let client = this.currentServer.client;
    if (!client.ingame) {
      client.socket.write(packet.data);
      client.socket.pause();

      // Give client time to display kick message
      setTimeout(() => {
        client.socket.destroy();
      }, 200);
    } else {
      let reader: PacketReader = new PacketReader(packet.data);
      var dcReason = reader.readNetworkText();
      var color = "C8FF00";
      var message = "[The dimension you were in disconnected you]";
      client.sendChatMessage(message, color);
      client.sendChatMessage(new NetworkText(1, "Reason: {0}", [ dcReason ]), color);
      client.wasKicked = true;
      client.connected = false;

      if (this.socket) {
        this.socket.destroy();
      }
    }

    return true;
  }

  /**
   * Passes on the real IP of the client to the server
   *
   * @param The continue connecting packet
   * @return Whether or not this packet was handled (and should not be sent)
   */
  private handleContinueConnecting(packet: RawPacket): boolean {
    let reader: PacketReader = new PacketReader(packet.data);
    this.currentServer.client.player.id = reader.readByte();

    // Send IP Address
    let ip: string = getProperIP(this.currentServer.client.socket.remoteAddress as string) as string;
    const packetData = new PacketWriter()
      .setType(PacketTypes.DimensionsUpdate)
      .packInt16(0) // Type
      .packString(ip)
      .data;

    this.currentServer.socket.write(packetData);

    return false;
  }

  /**
   * Restores player data and updates the SSC tracking
   *
   * @param The world info packet
   * @return Whether or not this packet was handled (and should not be sent)
   */
  private handleWorldInfo(packet: RawPacket): boolean {
    let reader: PacketReader = new PacketReader(packet.data);
    reader.readInt32(); // Time
    reader.readByte(); // Day&MoonInfo
    reader.readByte(); // Moon Phase
    reader.readInt16(); // MaxTilesX
    reader.readInt16(); // MaxTilesY
    let spawn: Point = {
      x: reader.readInt16(),
      y: reader.readInt16()
    };
    reader.readInt16(); // WorldSurface
    reader.readInt16(); // RockLayer
    reader.readInt32(); // WorldID
    reader.readString(); // World Name
    reader.readByte(); // Gamemode
    reader.readBytes(16); // World Unique ID
    reader.readUInt64(); // World Generator Version
    reader.readByte(); // Moon Type
    reader.readByte(); // Tree Background
    reader.readByte(); // Tree Background 2
    reader.readByte(); // Tree Background 3
    reader.readByte(); // Tree Background 4
    reader.readByte(); // Corruption Background
    reader.readByte(); // Jungle Background
    reader.readByte(); // Snow Background
    reader.readByte(); // Hallow Background
    reader.readByte(); // Crimson Background
    reader.readByte(); // Desert Background
    reader.readByte(); // Ocean Background
    reader.readByte(); // Mushroom Background
    reader.readByte(); // Underworld Background
    reader.readByte(); // Ice Back Style
    reader.readByte(); // Jungle Back Style
    reader.readByte(); // Hell Back Style
    reader.readSingle(); // Wind Speed Set
    reader.readByte(); // Cloud Number
    reader.readInt32(); // Tree 1
    reader.readInt32(); // Tree 2
    reader.readInt32(); // Tree 3
    reader.readByte(); // Tree Style 1
    reader.readByte(); // Tree Style 2
    reader.readByte(); // Tree Style 3
    reader.readByte(); // Tree Style 4
    reader.readInt32(); // Cave Back 1
    reader.readInt32(); // Cave Back 2
    reader.readInt32(); // Cave Back 3
    reader.readByte(); // Cave Back Style 1
    reader.readByte(); // Cave Back Style 2
    reader.readByte(); // Cave Back Style 3
    reader.readByte(); // Cave Back Style 4
    reader.readByte(); // Tree Tops Variation 1
    reader.readByte(); // Tree Tops Variation 2
    reader.readByte(); // Tree Tops Variation 3
    reader.readByte(); // Tree Tops Variation 4
    reader.readByte(); // Tree Tops Variation 5
    reader.readByte(); // Tree Tops Variation 6
    reader.readByte(); // Tree Tops Variation 7
    reader.readByte(); // Tree Tops Variation 8
    reader.readByte(); // Tree Tops Variation 9
    reader.readByte(); // Tree Tops Variation 10
    reader.readByte(); // Tree Tops Variation 11
    reader.readByte(); // Tree Tops Variation 12
    reader.readByte(); // Tree Tops Variation 13
    reader.readSingle(); // Rain
    let eventInfo = new BitsByte(reader.readByte());
    this.currentServer.isSSC = eventInfo[6];

    if (this.currentServer.client.waitingCharacterRestore && !this.currentServer.isSSC) {
      this.restoreInventory(this.currentServer.client);
      this.restoreLife(this.currentServer.client);
      this.restoreMana(this.currentServer.client);
      this.restoreVisuals(this.currentServer.client);
    }
    this.currentServer.client.waitingCharacterRestore = false;

    if (this.currentServer.client.state === ClientState.ConnectionSwitchEstablished) {
      this.currentServer.spawn.x = spawn.x;
      this.currentServer.spawn.y = spawn.y;

      // In future it would be better to check if they used a warpplate
      // so the tile section is where they came through instead of spawn
      let getSection = new PacketWriter()
        .setType(PacketTypes.GetSectionOrRequestSync)
        .packSingle(-1)
        .packSingle(-1)
        .data;
      this.currentServer.socket.write(getSection);

      this.currentServer.client.state = ClientState.FinalisingSwitch;

      // Routing Information for Warpplate entry
      if (this.currentServer.client.routingInformation !== null) {
        const strLen = getPackedStringByteLen(this.currentServer.client.routingInformation.info);
        let dimensionsUpdate = new PacketWriter()
          .setType(PacketTypes.DimensionsUpdate)
          .packInt16(this.currentServer.client.routingInformation.type)
          .packString(this.currentServer.client.routingInformation.info)
          .data;
        this.currentServer.socket.write(dimensionsUpdate);
        this.currentServer.client.routingInformation = null;
      }
    }

    return false;
  }

  /**
   * Ensures the player spawns correctly by sending the SpawnPlayer packet
   * that forces them to spawn if they're already in-game (on the world
   *
   * @param packet The complete connection and spawn packet
   * @return Whether or not the packet has been handled (and is not to be sent)
   */
  private handleCompleteConnectionAndSpawn(packet: RawPacket): boolean {
    let server: TerrariaServer = this.currentServer;
    if (this.currentServer.client.state === ClientState.FinalisingSwitch) {
      this.currentServer.client.state = ClientState.FinishinedSendingInventory;
      let spawnPlayer = new PacketWriter()
        .setType(PacketTypes.SpawnPlayer)
        .packByte(this.currentServer.client.player.id)
        .packInt16(this.currentServer.spawn.x)
        .packInt16(this.currentServer.spawn.y)
        .packInt32(0)
        .packByte(0)
        .data;

      if (typeof server.client !== 'undefined' && typeof server.client.socket !== 'undefined') {
        server.socket.write(spawnPlayer);

        if (!server.client.preventSpawnOnJoin) {
          server.client.socket.write(spawnPlayer);
        }
      }
    }


    if (server.client.state === ClientState.FinishinedSendingInventory) {
      server.client.state = ClientState.FullyConnected;
      server.client.sendWaitingPackets();
      server.sendWaitingPackets();

      for (let key in server.client.globalHandlers.extensions) {
        const e = server.client.globalHandlers.extensions[key];
        if (e.clientFullyConnectedHandler) {
          e.clientFullyConnectedHandler(server.client);
        }
      }
    }

    this.currentServer.client.ingame = true;
    return false;
  }

  /**
   * Handles the event that a warpplate requests switch of Dimension
   *
   * @param packet The dimensions update packet
   * @return Whether or not the packet has been handled (and is not to be sent)
   */
  private handleDimensionsUpdate(packet: RawPacket): boolean {
    const reader: PacketReader = new PacketReader(packet.data);
    const messageType: number = reader.readInt16();
    const messageContent: string = reader.readString();

    // Switch server
    if (messageType === 2) {
      if (this.currentServer.client.servers[messageContent.toLowerCase()]) {
        this.currentServer.client.sendChatMessage("Shifting to the " + messageContent + " Dimension", "FF0000");
        ClearUtils.clearPlayers(this.currentServer.client);
        ClearUtils.clearNPCs(this.currentServer.client);
        ClearUtils.clearItems(this.currentServer.client);
        this.currentServer.client.changeServer(this.currentServer.client.servers[messageContent.toLowerCase()], {
          preventSpawnOnJoin: false
        });
      }
    }

    if (messageType === 3) {
      const ip = messageContent;
      const port: number = reader.readUInt16();
      ClearUtils.clearPlayers(this.currentServer.client);
      ClearUtils.clearNPCs(this.currentServer.client);
      ClearUtils.clearItems(this.currentServer.client);
      this.currentServer.client.changeServer({
        name: `${ip}:${port}`,
        serverIP: ip,
        serverPort: port,
        hidden: false
      }, {
        preventSpawnOnJoin: false
      });
    }

    return true;
  }

  /**
   * Tracks whether an NPC is alive or not, so it can be cleared when the player switches Dimensions
   *
   * @param packet The NPC Update
   * @return Whether or not the packet has been handled (and is not to be sent)
   */
  private handleNPCUpdate(packet: RawPacket): boolean {
    let reader: PacketReader = new PacketReader(packet.data);
    let npcId: number = reader.readInt16();
    let position: Point = {
      x: reader.readSingle(),
      y: reader.readSingle()
    };
    let velocity: Point = {
      x: reader.readSingle(),
      y: reader.readSingle()
    };
    let target: number = reader.readUInt16();

    // Flags
    let flags: number = reader.readByte();
    let flags2: number = reader.readByte();
    let direction: boolean = (flags & 1) === 1;
    let directionY: boolean = (flags & 2) === 2;
    let AIFlags: boolean[] = [];
    AIFlags[0] = (flags & 4) === 4;
    AIFlags[1] = (flags & 8) === 8;
    AIFlags[2] = (flags & 16) === 16;
    AIFlags[3] = (flags & 32) === 32;
    let spriteDirection: boolean = (flags & 64) === 64;
    let lifeMax: boolean = (flags & 128) === 128;

    let AI: number[] = [];
    if (AIFlags[0]) {
      AI[0] = reader.readSingle();
    }
    if (AIFlags[1]) {
      AI[1] = reader.readSingle();
    }
    if (AIFlags[2]) {
      AI[2] = reader.readSingle();
    }
    if (AIFlags[3]) {
      AI[3] = reader.readSingle();
    }

    let netID: number = reader.readInt16();
    let playerCountForMultiplayerDifficultyOverride = null;
    if ((flags2 & 1) === 1)
    {
      playerCountForMultiplayerDifficultyOverride = reader.readByte();
    }
    let strengthMultiplier = null;
    if ((flags2 & 4) === 4)
    {
      strengthMultiplier = reader.readSingle();
    }
    let life: number = 0;
    let lifeBytes: number = 0;
    if (!lifeMax) {
      lifeBytes = reader.readByte();
      if (lifeBytes == 2) {
        life = reader.readInt16();
      } else if (lifeBytes == 4) {
        life = reader.readInt32();
      } else {
        life = reader.readSByte();
      }
    } else {
      // Placeholder max
      life = 1;
    }
    let releaseOwner: boolean = reader.head < packet.data.length && reader.readByte() > 0;

    if (netID === 0 || life === 0) {
      this.currentServer.entityTracking.NPCs[npcId] = undefined;
    } else {
      let npc: NPC | undefined = this.currentServer.entityTracking.NPCs[npcId]
      if (npc === undefined) {
        this.currentServer.entityTracking.NPCs[npcId] = new NPC(npcId, netID, life);
      } else {
        npc.life = life;
        npc.type = netID;
      }
    }

    return false;
  }

  /**
   * Tracks item drops so they can be cleared when the player switches Dimensions
   *
   * @param The update item drop packet
   * @return Whether or not this packet was handled (and should not be sent)
   */
  private handleUpdateItemDrop(packet: RawPacket): boolean {
    let reader: PacketReader = new PacketReader(packet.data);
    let itemID: number = reader.readInt16();
    let position: Point = {
      x: reader.readSingle(),
      y: reader.readSingle()
    };
    let velocity: Point = {
      x: reader.readSingle(),
      y: reader.readSingle()
    };
    let stacks: number = reader.readInt16();
    let prefix: number = reader.readByte();
    let noDelay: number = reader.readByte();
    var netID: number = reader.readInt16();

    if (netID > 0) {
      this.currentServer.entityTracking.items[itemID] = new Item(itemID, stacks, prefix, netID);
    } else {
      this.currentServer.entityTracking.items[itemID] = undefined;
    }
    return false;
  }

  /**
   * Tracks which players are active so they can be cleared when a player switches Dimensions
   *
   * @param The player active packet
   * @return Whether or not this packet was handled (and should not be sent)
   */
  private handlePlayerActive(packet: RawPacket): boolean {
    let reader: PacketReader = new PacketReader(packet.data);
    let playerID: number = reader.readByte();
    let active: boolean = reader.readByte() === 1;
    let player: Player | undefined = undefined;
    if (active) {
      player = new Player(null);
    }
    this.currentServer.entityTracking.players[playerID] = player;

    return false;
  }

  /**
   * Holds back slot updates until player is ready to spawn for the first time
   * on the current Dimension
   *
   * @param packet The player inventory slot packet
   */
  private handlePlayerInventorySlot(packet: RawPacket): boolean {
    let handled = false;
    let reader: PacketReader = new PacketReader(packet.data);
    let playerID: number = reader.readByte();
    if (playerID === this.currentServer.client.player.id) {
      if (this.currentServer.client.state !== ClientState.FullyConnected) {
        this.currentServer.packetQueue.push(packet.data);
        handled = true;
      }
    }

    return handled;
  }

  private handlePlayerInfo(packet: RawPacket): boolean {
    const reader = new PacketReader(packet.data);
    const playerId = reader.readByte();
    const skinVariant = reader.readByte();
    let hair = reader.readByte();
    if (hair > 134) {
      hair = 0;
    }
    const name = reader.readString();
    const hairDye = reader.readByte();
    const hideVisuals = reader.readByte();
    const hideVisuals2 = reader.readByte();
    const hideMisc = reader.readByte();
    const hairColor = reader.readColor();
    const skinColor = reader.readColor();
    const eyeColor = reader.readColor();
    const shirtColor = reader.readColor();
    const underShirtColor = reader.readColor();
    const pantsColor = reader.readColor();
    const shoeColor = reader.readColor();
    const difficulty = reader.readByte();
    const torchFlags = reader.readByte();

    const nameMismatchesRequireRewrite = this.currentServer.client.options.nameChanges?.mode === "rewrite";
    const isAboutCurrentClient = playerId === this.currentServer.client.player.id;
    const isMismatchedName = this.currentServer.client.player.name !== name;
    const isAllowedToRename = (this.currentServer.client.options.nameChanges?.exclusions.indexOf(this.currentServer.name) ?? -1) > -1;
    if (nameMismatchesRequireRewrite && isAboutCurrentClient && isMismatchedName) {
      if (!isAllowedToRename) {
          const playerInfo = new PacketWriter()
            .setType(PacketTypes.PlayerInfo)
            .packByte(playerId)
            .packByte(skinVariant)
            .packByte(hair)
            .packString(this.currentServer.client.player.name)
            .packByte(hairDye)
            .packByte(hideVisuals)
            .packByte(hideVisuals2)
            .packByte(hideMisc)
            .packColor(hairColor)
            .packColor(skinColor)
            .packColor(eyeColor)
            .packColor(shirtColor)
            .packColor(underShirtColor)
            .packColor(pantsColor)
            .packColor(shoeColor)
            .packByte(difficulty)
            .packByte(torchFlags)
            .data;
            packet.data = playerInfo;
      } else {
        this.currentServer.client.setName(name);
      }
    }

    return false;
  }

  /**
   * Sets the players slots back to what they were before they joined the SSC server.
   * Used when a player switches from an SSC server to a non-SSC server
   *
   * @param client Which client is getting its inventory restored
   */
  private restoreInventory(client: Client): void {
    for (const item of this.currentServer.client.player.inventory) {
      if (typeof item !== "undefined") {
        client.player.setItem(item);
      }
    }
  }

  /**
   * Sets the players life back to what they were before they joined the SSC server.
   * Used when a player switches from an SSC server to a non-SSC server
   *
   * @param client Which client is getting its life restored
   */
  private restoreLife(client: Client): void {
    client.player.setLife(this.currentServer.client.player.life);
  }

  /**
   * Sets the players mana back to what they were before they joined the SSC server.
   * Used when a player switches from an SSC server to a non-SSC server
   *
   * @param client Which client is getting its mana restored
   */
  private restoreMana(client: Client): void {
    client.player.setMana(this.currentServer.client.player.mana);
  }

  /**
   * Sets the players visuals back to what they were before they joined the SSC server.
   * Used when a player switches from an SSC server to a non-SSC server
   *
   * @param client Which client is getting its visuals restored
   */
  private restoreVisuals(client: Client): void {
    client.player.setVisuals();
  }
};

export default TerrariaServerPacketHandler;
