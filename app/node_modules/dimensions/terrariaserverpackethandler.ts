import PacketTypes from 'dimensions/packettypes';
import NetworkText from 'dimensions/packets/networktext';
import PacketReader from 'dimensions/packets/packetreader';
import PacketWriter from 'dimensions/packets/packetwriter';
import { getProperIP } from 'dimensions/utils';
import NPC from 'dimensions/npc';
import TerrariaServer from 'dimensions/terrariaserver';
import Client from 'dimensions/client';
import RawPacket from 'dimensions/packets/rawpacket';
import * as Net from 'net';
import Item from 'dimensions/item';
import Player from 'dimensions/player';
import ClientState from 'dimensions/clientstate';
import * as fs from "fs";

import * as WorldInfo from "rescript-terrariapacket/src/packet/Packet_WorldInfo.gen";
import * as PlayerInfo from "rescript-terrariapacket/src/packet/Packet_PlayerInfo.gen";
import * as NpcUpdate from "rescript-terrariapacket/src/packet/Packet_NpcUpdate.gen";
import * as ItemDropUpdate from "rescript-terrariapacket/src/packet/Packet_ItemDropUpdate.gen";

/**
 * This handles all packets coming from a Terraria Server, sometimes responding instead of the client
 * to ensure a smooth and successful transition between servers (due to a client state prohibiting a
 * certain response)
 */
class TerrariaServerPacketHandler {
  private currentServer!: TerrariaServer;
  private socket?: Net.Socket;

  /**
   * Checks whether the packet was handled by extensions prior to being processed by this class
   *
   * @param server The server object assigned to a player that is sending a packet
   * @param packet The packet that is being sent
   * @return Whether or not the packet was handled (and should not be sent)
   */
  private runPriorHandlers(server: TerrariaServer, packet: RawPacket): boolean {
    let handlers = server.client.globalHandlers.extensions;
    let handled = false;
    for (let key in handlers) {
      let handler = handlers[key];
      if (typeof handler.priorPacketHandlers !== 'undefined' && typeof handler.priorPacketHandlers.serverHandler !== 'undefined') {
        handled = handler.priorPacketHandlers.serverHandler.handlePacket(server, packet);
        if (handled) {
          break;
        }
      }
    }

    return handled;
  }

  /**
   * Checks whether the packet was handled by extensions after being processed by this class
   *
   * @param server The server object assigned to a player that is sending a packet
   * @param packet The packet that is being sent
   * @return Whether or not the packet was handled (and should not be sent)
   */
  private runPostHandlers(server: TerrariaServer, packet: RawPacket): boolean {
    let handlers = server.client.globalHandlers.extensions;
    let handled = false;
    for (let key in handlers) {
      let handler = handlers[key];
      if (typeof handler.postPacketHandlers !== 'undefined' && typeof handler.postPacketHandlers.serverHandler !== 'undefined') {
        handled = handler.postPacketHandlers.serverHandler.handlePacket(server, packet);
        if (handled) {
          break;
        }
      }
    }

    return handled;
  }

  /**
   * Runs the packet through extension handlers and runs any appropriate handlers of this class
   *
   * @param server The server object assigned to a player that is sending a packet
   * @param packet The packet that is being sent
   * @return The packet data (either origin or modified)
   */
  public handlePacket(server: TerrariaServer, packet: RawPacket): Buffer | null {
    this.currentServer = server;

    let priorHandled: boolean = this.runPriorHandlers(server, packet);
    if (priorHandled) {
      return null;
    }

    let handled: boolean = false;
    let packetType: number = packet.packetType;

    switch (packetType) {
      case PacketTypes.Disconnect:
        handled = this.handleDisconnect(packet);
        break;

      case PacketTypes.ContinueConnecting:
        handled = this.handleContinueConnecting(packet);
        break;

      case PacketTypes.WorldInfo:
        handled = this.handleWorldInfo(packet);
        break;

      case PacketTypes.CompleteConnectionAndSpawn:
        handled = this.handleCompleteConnectionAndSpawn(packet);
        break;

      case PacketTypes.DimensionsUpdate:
        handled = this.handleDimensionsUpdate(packet);
        break;

      case PacketTypes.NPCUpdate:
        handled = this.handleNPCUpdate(packet);
        break;

      case PacketTypes.UpdateItemDrop_Instanced:
      case PacketTypes.UpdateItemDrop:
        handled = this.handleUpdateItemDrop(packet);
        break;

      case PacketTypes.PlayerActive:
        handled = this.handlePlayerActive(packet);
        break;

      case PacketTypes.PlayerInventorySlot:
        handled = this.handlePlayerInventorySlot(packet);
        break;

      case PacketTypes.PlayerInfo:
        handled = this.handlePlayerInfo(packet);
        break;

      default:
        break;
    }

    if (handled) {
      return null;
    }

    let postHandled: boolean = this.runPostHandlers(server, packet);
    if (postHandled) {
      return null;
    }

    return packet.data;
  }

  /**
   * Passes on the disconnect message as a chat message to the client, unless the client
   * has not fully connected to any Dimension yet.
   *
   * @param packet The disconnect packet
   * @return Whether or not this packet was handled (and should not be sent)
   */
  private handleDisconnect(packet: RawPacket): boolean {
    let client = this.currentServer.client;
    if (!client.ingame) {
      client.socket.write(packet.data);
      client.socket.pause();

      // Give client time to display kick message
      setTimeout(() => {
        client.socket.destroy();
      }, 200);
    } else {
      let reader: PacketReader = new PacketReader(packet.data);
      var dcReason = reader.readNetworkText();
      var color = "C8FF00";
      var message = client.options.language.phrases.dimensionDisconnectedYou;
      client.sendChatMessage(message, color);
      client.sendChatMessage(new NetworkText(1, client.options.language.phrases.reason + "{0}", [dcReason]), color);
      client.wasKicked = true;
      client.connected = false;

      if (this.socket) {
        this.socket.destroy();
      }
    }

    return true;
  }

  /**
   * Passes on the real IP of the client to the server
   *
   * @param packet The continue connecting packet
   * @return Whether or not this packet was handled (and should not be sent)
   */
  private handleContinueConnecting(packet: RawPacket): boolean {
    let reader: PacketReader = new PacketReader(packet.data);
    this.currentServer.client.player.id = reader.readByte();

    // Send IP Address
    if (!this.currentServer.isVanilla) {
      let ip: string = getProperIP(this.currentServer.client.socket.remoteAddress as string) as string;
      const packetData = new PacketWriter()
        .setType(PacketTypes.DimensionsUpdate)
        .packInt16(0) // Type
        .packString(ip)
        .data;

      this.currentServer.socket.write(packetData);
    }

    return false;
  }

  /**
   * Restores player data and updates the SSC tracking
   *
   * @param packet The world info packet
   * @return Whether or not this packet was handled (and should not be sent)
   */
  private handleWorldInfo(packet: RawPacket): boolean {
    const worldInfo = WorldInfo.parse(packet.data);
    if (typeof worldInfo === 'undefined') {
      return false;
    }

    this.currentServer.isSSC = worldInfo.eventInfo.serverSidedCharacters;

    if (this.currentServer.client.waitingCharacterRestore && !this.currentServer.isSSC) {
      this.restoreInventory(this.currentServer.client);
      this.restoreLife(this.currentServer.client);
      this.restoreMana(this.currentServer.client);
      this.restoreVisuals(this.currentServer.client);
    }
    this.currentServer.client.waitingCharacterRestore = false;

    if (this.currentServer.client.state === ClientState.ConnectionSwitchEstablished) {
      this.currentServer.spawn.x = worldInfo.spawnX;
      this.currentServer.spawn.y = worldInfo.spawnY;

      // In future it would be better to check if they used a warpplate
      // so the tile section is where they came through instead of spawn
      let getSection = new PacketWriter()
        .setType(PacketTypes.GetSectionOrRequestSync)
        .packSingle(-1)
        .packSingle(-1)
        .data;
      this.currentServer.socket.write(getSection);

      this.currentServer.client.state = ClientState.FinalisingSwitch;

      // Routing Information for Warpplate entry
      if (this.currentServer.client.routingInformation !== null) {
        let dimensionsUpdate = new PacketWriter()
          .setType(PacketTypes.DimensionsUpdate)
          .packInt16(this.currentServer.client.routingInformation.type)
          .packString(this.currentServer.client.routingInformation.info)
          .data;
        this.currentServer.socket.write(dimensionsUpdate);
        this.currentServer.client.routingInformation = null;
      }
    }

    return false;
  }

  /**
   * Ensures the player spawns correctly by sending the SpawnPlayer packet
   * that forces them to spawn if they're already in-game (on the world
   *
   * @param packet The complete connection and spawn packet
   * @return Whether or not the packet has been handled (and is not to be sent)
   */
  private handleCompleteConnectionAndSpawn(packet: RawPacket): boolean {
    let server: TerrariaServer = this.currentServer;
    if (this.currentServer.client.state === ClientState.FinalisingSwitch) {
      this.currentServer.client.state = ClientState.FinishinedSendingInventory;
      let spawnPlayer = new PacketWriter()
        .setType(PacketTypes.SpawnPlayer)
        .packByte(this.currentServer.client.player.id)
        .packInt16(this.currentServer.spawn.x)
        .packInt16(this.currentServer.spawn.y)
        .packInt32(0)
        .packByte(0)
        .data;

      if (typeof server.client !== 'undefined' && typeof server.client.socket !== 'undefined') {
        server.socket.write(spawnPlayer);

        if (!server.client.preventSpawnOnJoin) {
          server.client.socket.write(spawnPlayer);
        }
      }
    }


    if (server.client.state === ClientState.FinishinedSendingInventory) {
      server.client.state = ClientState.FullyConnected;
      server.client.sendWaitingPackets();
      server.sendWaitingPackets();

      for (let key in server.client.globalHandlers.extensions) {
        const e = server.client.globalHandlers.extensions[key];
        if (e.clientFullyConnectedHandler) {
          e.clientFullyConnectedHandler(server.client);
        }
      }
    }

    this.currentServer.client.ingame = true;
    return false;
  }

  /**
   * Handles the event that a warpplate requests switch of Dimension
   *
   * @param packet The dimensions update packet
   * @return Whether or not the packet has been handled (and is not to be sent)
   */
  private handleDimensionsUpdate(packet: RawPacket): boolean {
    const reader: PacketReader = new PacketReader(packet.data);
    const messageType: number = reader.readInt16();
    const messageContent: string = reader.readString();

    // Switch server
    if (messageType === 2) {
      if (this.currentServer.client.servers[messageContent.toLowerCase()]) {
        const phrases = this.currentServer.client.options.language.phrases;
        this.currentServer.client.sendChatMessage(phrases.shiftingToDimension.replace("${name}", messageContent), "FF0000");
        this.currentServer.client.changeServer(this.currentServer.client.servers[messageContent.toLowerCase()], {
          preventSpawnOnJoin: false
        });
      }
    }

    if (messageType === 3) {
      const ip = messageContent;
      const port: number = reader.readUInt16();
      this.currentServer.client.changeServer({
        name: `${ip}:${port}`,
        serverIP: ip,
        serverPort: port,
        hidden: false,
        isVanilla: false,
      }, {
        preventSpawnOnJoin: false
      });
    }

    return true;
  }

  /**
   * Tracks whether an NPC is alive or not, so it can be cleared when the player switches Dimensions
   *
   * @param packet The NPC Update
   * @return Whether or not the packet has been handled (and is not to be sent)
   */
  private handleNPCUpdate(packet: RawPacket): boolean {
    const npcUpdate = NpcUpdate.parse(packet.data);
    if (typeof npcUpdate === "undefined") {
      return false;
    }

    const { npcSlotId, npcTypeId, life } = npcUpdate;

    let zeroLife = false;
    if (life != "Max") {
      zeroLife = life.value === 0;
    }
    if (npcTypeId === 0 || zeroLife) {
      this.currentServer.entityTracking.NPCs[npcSlotId] = undefined;
    } else {
      let npc: NPC | undefined = this.currentServer.entityTracking.NPCs[npcSlotId]
      if (npc === undefined) {
        this.currentServer.entityTracking.NPCs[npcSlotId] = new NPC(npcSlotId, npcTypeId, life === "Max" ? 1 : life.value);
      } else {
        npc.life = life === "Max" ? 1 : life.value;
        npc.type = npcTypeId;
      }
    }

    return false;
  }

  /**
   * Tracks item drops so they can be cleared when the player switches Dimensions
   *
   * @param packet The update item drop packet
   * @return Whether or not this packet was handled (and should not be sent)
   */
  private handleUpdateItemDrop(packet: RawPacket): boolean {
    const itemDropUpdate = ItemDropUpdate.parse(packet.data);
    if (typeof itemDropUpdate === "undefined") {
      return false;
    }

    const { itemDropId, stack, prefix, itemId } = itemDropUpdate;
    if (itemDropId > 0) {
      this.currentServer.entityTracking.items[itemDropId] = new Item(itemDropId, stack, prefix, itemId);
    } else {
      this.currentServer.entityTracking.items[itemDropId] = undefined;
    }
    return false;
  }

  /**
   * Tracks which players are active so they can be cleared when a player switches Dimensions
   *
   * @param packet The player active packet
   * @return Whether or not this packet was handled (and should not be sent)
   */
  private handlePlayerActive(packet: RawPacket): boolean {
    let reader: PacketReader = new PacketReader(packet.data);
    let playerID: number = reader.readByte();
    let active: boolean = reader.readByte() === 1;
    let player: Player | undefined = undefined;
    if (active) {
      player = new Player(null);
    }
    this.currentServer.entityTracking.players[playerID] = player;

    return false;
  }

  /**
   * Holds back slot updates until player is ready to spawn for the first time
   * on the current Dimension
   *
   * @param packet The player inventory slot packet
   */
  private handlePlayerInventorySlot(packet: RawPacket): boolean {
    let handled = false;
    let reader: PacketReader = new PacketReader(packet.data);
    let playerID: number = reader.readByte();
    if (playerID === this.currentServer.client.player.id) {
      if (this.currentServer.client.state !== ClientState.FullyConnected) {
        this.currentServer.packetQueue.push(packet.data);
        handled = true;
      }
    }

    return handled;
  }

  private handlePlayerInfo(packet: RawPacket): boolean {
    const playerInfo = PlayerInfo.parse(packet.data);
    if (typeof playerInfo === "undefined") {
      return false;
    }

    const nameMismatchesRequireRewrite = this.currentServer.client.options.nameChanges?.mode === "rewrite";
    const isAboutCurrentClient = playerInfo.playerId === this.currentServer.client.player.id;
    const isMismatchedName = this.currentServer.client.player.name !== playerInfo.name;
    const isAllowedToRename = (this.currentServer.client.options.nameChanges?.exclusions.indexOf(this.currentServer.name) ?? -1) > -1;
    if (nameMismatchesRequireRewrite && isAboutCurrentClient && isMismatchedName) {
      if (!isAllowedToRename) {
        packet.data = PlayerInfo.toBuffer({ ...playerInfo, name: this.currentServer.client.player.name });
      } else {
        this.currentServer.client.setName(playerInfo.name);
      }
    }

    return false;
  }

  /**
   * Sets the players slots back to what they were before they joined the SSC server.
   * Used when a player switches from an SSC server to a non-SSC server
   *
   * @param client Which client is getting its inventory restored
   */
  private restoreInventory(client: Client): void {
    for (const item of this.currentServer.client.player.inventory) {
      if (typeof item !== "undefined") {
        client.player.setItem(item);
      }
    }
  }

  /**
   * Sets the players life back to what they were before they joined the SSC server.
   * Used when a player switches from an SSC server to a non-SSC server
   *
   * @param client Which client is getting its life restored
   */
  private restoreLife(client: Client): void {
    client.player.restoreSavedMaxHealth();
  }

  /**
   * Sets the players mana back to what they were before they joined the SSC server.
   * Used when a player switches from an SSC server to a non-SSC server
   *
   * @param client Which client is getting its mana restored
   */
  private restoreMana(client: Client): void {
    client.player.restoreSavedMaxMana();
  }

  /**
   * Sets the players visuals back to what they were before they joined the SSC server.
   * Used when a player switches from an SSC server to a non-SSC server
   *
   * @param client Which client is getting its visuals restored
   */
  private restoreVisuals(client: Client): void {
    client.player.setVisuals();
  }
};

export default TerrariaServerPacketHandler;
