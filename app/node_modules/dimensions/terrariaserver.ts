import { BuffersPackets, getPacketsFromBuffer } from 'dimensions/utils';
import * as _ from 'lodash';
import terrariaServerPacketHandler from 'dimensions/terrariaserverpackethandler';
import Client from 'dimensions/client';
import * as Net from 'net';
import Point from 'dimensions/point';
import RawPacket from 'dimensions/packets/rawpacket';
import Entities from 'dimensions/entities';
import ClientState from 'dimensions/clientstate';

/* Used to track information specific to the current server that a client is on
 * as well as pass received data from the TerrariaServer to the handlers */
class TerrariaServer {
  public client: Client;
  public socket: Net.Socket;

  // Connection Details
  public ip!: string;
  public port!: number;

  // Unique name
  public name!: string;
  public spawn!: Point;
  public afterClosed!: ((client: Client) => void) | null;
  public entityTracking!: Entities;
  public isSSC!: boolean;
  public packetQueue!: Buffer[];
  private bufferPacket!: Buffer;

  constructor(socket: Net.Socket, client: Client) {
    this.socket = socket;
    this.client = client;
    this.reset();
  }

  public reset(): void {
    this.ip = "127.0.0.1";
    this.port = 7777;
    this.name = "";
    this.spawn = {
      x: 0,
      y: 0
    };
    this.bufferPacket = Buffer.allocUnsafe(0);
    this.afterClosed = null;
    this.entityTracking = {
      items: [],
      NPCs: [],
      players: []
    };
    this.isSSC = false;
    this.packetQueue = [];
  }

  public getPacketHandler(): terrariaServerPacketHandler {
    return this.client.globalHandlers.terrariaServerPacketHandler;
  }

  /* Handles all data coming from the TerrariaServer */
  public handleData(encodedData: Buffer): void {
    try {
      // This is the incomplete packet carried over from last time
      let bufferPacket = this.bufferPacket;

      // The combined packet info using buffer
      let entireData = Buffer.concat([bufferPacket, encodedData]);

      // Get an array of packets from the entireData
      let entireDataInfo: BuffersPackets = getPacketsFromBuffer(entireData);

      // Update buffer packet to the new incomplete packet (if any)
      this.bufferPacket = entireDataInfo.bufferPacket;

      // The hex string of the allowed packets to send to the client
      let allowedPackets: Buffer[] = [];

      // Inspect and handle each packet
      let packets: RawPacket[] = entireDataInfo.packets;
      _.each(packets, (packet: RawPacket) => {
        const buf = this.getPacketHandler().handlePacket(this, packet);
        if (buf !== null) {
          allowedPackets.push(buf);
        }
      });

      if (allowedPackets.length > 0) {
        if (!this.client.socket.destroyed && this.client.socket.writable) {
          for (const buf of allowedPackets) {
            this.client.socket.write(buf);
          }
        } else {
          this.socket.destroy();
        }
      }
    } catch (e) {
      if (this.client.options.log.tServerError) {
        if (this.client.options.log.outputToConsole) {
          console.log(`TS Handle Data Error: ${e.stack}`);
        }

        this.client.logging.appendLine(`TS Handle Data Error: ${e.stack}`);
      }
    }
  }

  /* Sends any queued packets from the connection phase to the client */
  public sendWaitingPackets(): void {
    if (!this.socket.destroyed && this.packetQueue.length > 0) {
      for (const packet of this.packetQueue) {
        this.client.socket.write(packet);
      }
      
      this.packetQueue = [];
    }
  }

  /* Calls all server disconnect pre-handlers from extensions
   * and returns whether the disconnect was handled by them.*/
  private handledByPreCloseHandlers(): boolean {
    let handlers = this.client.globalHandlers.extensions;
    let handled = false;
    for (let key in handlers) {
      let handler = handlers[key];
      if (typeof handler.serverDisconnectPreHandler !== 'undefined') {
        handled = handler.serverDisconnectPreHandler(this);
        if (handled) {
          break;
        }
      }
    }
    
    return handled;
  }

  /* Calls all server disconnect handlers from extensions
   * and returns whether the disconnect was handled by them.*/
  private handledByCloseHandlers(): boolean {
    let handlers = this.client.globalHandlers.extensions;
    let handled = false;
    for (let key in handlers) {
      let handler = handlers[key];
      if (typeof handler.serverDisconnectHandler !== 'undefined') {
        handled = handler.serverDisconnectHandler(this);
        if (handled) {
          break;
        }
      }
    }
    
    return handled;
  }

  /* Decrements server counts when the socket connection to the TerrariaServer
   * is closed, sends a message to the client and runs any handlers of this 
   * event through extensions currently loaded */
  public handleClose(): void {
    this.client.connected = false;

    try {
      if (this.client.countIncremented) {
        this.client.serversDetails[this.name].clientCount--;
        this.client.countIncremented = false;
      }
    } catch (e) {
      if (this.client.options.log.tServerError) {
        if (this.client.options.log.outputToConsole) {
          console.log(`handleClose ERROR: ${e}`);
        }

        this.client.logging.appendLine(`handleClose ERROR: ${e}`);
      }
    }
    
    if (this.client.options.log.tServerDisconnect) {
      if (this.client.options.log.outputToConsole) {
        console.log(`TerrariaServer socket closed. [${this.name}]`);
      }

      this.client.logging.appendLine(`TerrariaServer socket closed. [${this.name}]`);
    }

    if (this.handledByPreCloseHandlers()) {
      return;
    }

    if (this.afterClosed !== null) {
      this.afterClosed(this.client);
    } else {
      if (this.handledByCloseHandlers()) {
        return;
      }

      let dimensionsList: string = "";
      let dimensionNames: string[] = _.keys(this.client.servers);
      for (var i = 0; i < dimensionNames.length; i++) {
        let name: string = dimensionNames[i];
        let hidden: boolean = this.client.servers[name].hidden;
        if (!hidden) {
          dimensionsList += (i > 0 ? ", " : " ") + "/" + dimensionNames[i];
        }
      }

      if (!this.client.wasKicked) {
        this.client.sendChatMessage("The dimension you were in dropped the connection.", "00BFFF");
        this.client.sendChatMessage("Specify a [c/FF00CC:Dimension] to travel to: " + dimensionsList, "00BFFF");
      } else {
        this.client.sendChatMessage("Specify a [c/FF00CC:Dimension] to travel to: " + dimensionsList, "00BFFF");
        this.client.wasKicked = false;
      }

      this.client.state = ClientState.Disconnected;
    }
  }

  /* Checks the type of error, if it is because a server is down, the failed connection attempts
   * property is incremented until it reaches 3 at which point it is marked as closed and will not
   * be used by clients. 
   * 
   * TODO: Handle non-refused errors when the host itself is offline */
  public handleError(error: Error): void {
    //console.log(this.ip + ":" + this.port + " " + this.name);
    //this.client.changeServer(Config.IP, Config.PORT);
    let matches: RegExpMatchArray | null = / E([A-z]*?) /.exec(error.message);
    let type: string = matches !== null && matches.length > 1 ? matches[1] : "";
    let serverDetails = this.client.serversDetails[this.name];

    if (type === "CONNREFUSED" || type === "TIMEDOUT") {
      if (!serverDetails.disabled && ++serverDetails.failedConnAttempts >= 3) {
        serverDetails.disabled = true;
        serverDetails.disabledTimeout = setTimeout(() => {
          serverDetails.failedConnAttempts = 0;
          serverDetails.disabled = false;
        }, 20000);
      }
    }

    if (this.client.options.log.tServerError) {
      if (this.client.options.log.outputToConsole) {
        console.log(`TerrariaServer Socket Error: ${error.message}`);
      }

      this.client.logging.appendLine(`TerrariaServer Socket Error: ${error.message}`);
    }
  }
}

export default TerrariaServer;
