import ClientArgs from 'dimensions/clientargs';
import RawPacket from 'dimensions/packets/rawpacket';
import { getPacketsFromBuffer, BuffersPackets } from 'dimensions/utils';
import { getProperIP } from 'dimensions/utils';
import Blacklist from 'dimensions/blacklist';
import * as PlayerSlotSet from 'terraria-packet/src/packet/Packet_PlayerSlotSet.gen';
import * as Parser from 'terraria-packet/src/Parser.gen';

enum ClientState {
    StartOfConnection,
    AssignedClientId,
    SentPlayerInfo,
    SentUuid,
}

interface BlacklistCheckClientArgs {
    blacklist: Blacklist,
    clientArgs: ClientArgs,
}

interface BlacklistCheckCallbackArgs {
    clientAcceptedCb: (bufferPacket: Buffer, packetsReceived: RawPacket[]) => void,
    clientBlacklistedCb: () => void
    errorCheckingBlacklistCb: (bufferPacket: Buffer, packetsReceived: RawPacket[], e: Error) => void
    packetErrorCheckingBlacklistCb: (e: Error) => void
    disconnectCb: () => void
}

class BlacklistCheckClient {
    private state: ClientState = ClientState.StartOfConnection;
    private name: string | undefined;
    private bufferPacket: Buffer = Buffer.alloc(0);
    private packetsReceived: RawPacket[] = [];
    private clientAcceptedCb!: (bufferPacket: Buffer, packetsReceived: RawPacket[]) => void;
    private clientBlacklistedCb!: () => void;
    private errorCheckingBlacklistCb!: (bufferPacket: Buffer, packetsReceived: RawPacket[], e: Error) => void;
    private packetErrorCheckingBlacklistCb!: (e: Error) => void;
    private disposed: boolean = false;

    constructor(private settings: BlacklistCheckClientArgs) {
        this.state = ClientState.AssignedClientId;
    }

    setupCallbacks(args: BlacklistCheckCallbackArgs) {
        this.clientAcceptedCb = args.clientAcceptedCb;
        this.clientBlacklistedCb = args.clientBlacklistedCb;
        this.errorCheckingBlacklistCb = args.errorCheckingBlacklistCb;
        this.packetErrorCheckingBlacklistCb = args.packetErrorCheckingBlacklistCb;

        this.settings.clientArgs.socket.on('data', this.handleData.bind(this));
        this.settings.clientArgs.socket.on('error', this.handleError.bind(this));
        this.settings.clientArgs.socket.on('timeout', this.handleTimeout.bind(this));
        this.settings.clientArgs.socket.on('close', () => {
            if (this.disposed) {
                return;
            }
            args.disconnectCb();
            this.dispose()
        })
        this.settings.clientArgs.socket.write(
            PlayerSlotSet.toBuffer(0)
        );
    }

    handleData(data: Buffer) {
        let bufferPacket = this.bufferPacket;
        let entireData = Buffer.concat([bufferPacket, data]);

        // Get the individual packets from the data
        let entireDataInfo: BuffersPackets = getPacketsFromBuffer(entireData);

        if (entireDataInfo.type === "InvalidPacketLength") {
            this.dispose()
            this.packetErrorCheckingBlacklistCb(new Error(`Invalid packet length ${entireDataInfo.length}`))
            return
        }

        // Update Buffer Packet using the new incomplete packet (if any)
        this.bufferPacket = entireDataInfo.bufferPacket;

        const packets: RawPacket[] = entireDataInfo.packets;
        this.packetsReceived.push(...packets);

        for (const packet of packets) {
            this.handlePacket(packet);
        }
    }

    handlePacket(rawPacket: RawPacket) {
        if (this.disposed) {
            return
        }

        const packet = Parser.parseLazy(rawPacket.data, false)
        if (packet == undefined) {
            return
        }

        switch (packet.TAG) {
            case "PlayerInfo":
                if (this.state !== ClientState.AssignedClientId) {
                    this.dispose()
                    this.packetErrorCheckingBlacklistCb(new Error("Client info packet received before assigning client ID"))
                    return
                }
                const playerInfo = packet._0.VAL();
                if (playerInfo === undefined) {
                    this.dispose()
                    this.packetErrorCheckingBlacklistCb(new Error("Client info packet could not be parsed"))
                    return
                }

                this.name = playerInfo.name;
                this.state = ClientState.SentPlayerInfo;
                break;
            case "ClientUuid":
                if (this.state !== ClientState.SentPlayerInfo) {
                    this.dispose()
                    this.packetErrorCheckingBlacklistCb(new Error("Client UUID packet received before player info"))
                    return
                }
                const clientUuid = packet._0.VAL();
                const ip = getProperIP(this.settings.clientArgs.socket.remoteAddress);
                if (clientUuid === undefined) {
                    this.dispose()
                    this.packetErrorCheckingBlacklistCb(new Error("Client UUID packet could not be parsed"))
                    return
                }
                if (this.name === undefined) {
                    this.dispose()
                    this.packetErrorCheckingBlacklistCb(new Error("Client name missing"))
                    return
                }
                if (ip === undefined) {
                    this.dispose()
                    this.packetErrorCheckingBlacklistCb(new Error("Client IP could not be parsed"))
                    return
                }

                this.settings.blacklist.checkInformation(this.name, ip, clientUuid.uuid).then((isBlacklisted) => {
                    if (this.disposed) {
                        return;
                    }
                    this.dispose()
                    if (isBlacklisted) {
                        this.clientBlacklistedCb();
                    } else {
                        this.clientAcceptedCb(this.bufferPacket, this.packetsReceived);
                    }
                }).catch((e) => {
                    if (this.disposed) {
                        return;
                    }
                    this.dispose()
                    this.errorCheckingBlacklistCb(this.bufferPacket, this.packetsReceived, e)
                })
                break;
        }
    }

    handleError(err: Error) {
        console.error("Error with client", err);
    }
    handleTimeout() {
        console.error("Client timed out");
    }

    dispose() {
        this.settings.clientArgs.socket.removeAllListeners();
        this.disposed = true;
    }
}

export default BlacklistCheckClient;
