import GlobalTracking from "dimensions/globaltracking";
import RoutingServer from "dimensions/routingserver";
import ServerDetails from "dimensions/serverdetails";
import { RestApiResponse } from "dimensions/configloader";
import * as Net from "net";
import * as uuid from "uuid";
import * as fs from "fs";

export interface TshockVersion {
    Major: number;
    Minor: number;
    Build: number;
    Revision: number;
    MajorRevision: number;
    MinorRevision: number;
}

export interface ApiResponse {
    status: number;
    name: string;
    serverversion: string;
    tshockversion: TshockVersion;
    port: number;
    playercount: number;
    maxplayers: number;
    world: string;
    uptime: string;
    serverpassword: boolean;
    players: string[] | string;
}

export interface ServersDetails {
    [id: string]: ServerDetails;
}

export interface RoutingServers {
    [id: string]: RoutingServer;
}

/* Responds to HTTP requests on the specified port with a tShock /v2/status response, which includes the player counts
 * and player names from all hosted Dimensions */
class RestApi {
    public servers: RoutingServers;
    public serversDetails: ServersDetails;
    private server!: Net.Server;
    private port: number;
    private globalTracking: GlobalTracking;
    private openSockets: { [id: string]: Net.Socket };
    private response?: RestApiResponse;

    constructor(port: number, globalTracking: GlobalTracking, serversDetails: ServersDetails, servers: RoutingServers, response: RestApiResponse | undefined) {
        this.servers = servers;
        this.port = port;
        this.globalTracking = globalTracking;
        this.serversDetails = serversDetails;
        this.response = response;
        this.openSockets = {};

        this.createServer();
        console.log(`\u001b[35mRestApi on ${port} started.\u001b[0m`);
    }

    /* Starts a new server listening for socket connections on the appropriate port */
    private createServer(): void {
        this.server = Net.createServer((socket) => {
            this.handleSocket(socket);
        }).on("error", (e) => {
            console.log(e);
        }).listen(this.port);
    }

    /* Used by the reload command to check if the port has changed, and if so
     * will close existing connections and the socket server, then start a new
     * one using the new port */
    public handleReload(port: number): void {
        if (this.port !== port) {
            const socketIds = Object.keys(this.openSockets);
            let id: string;
            for (let i = 0; i < socketIds.length; i++) {
                id = socketIds[i];
                this.openSockets[id].destroy();
            }

            this.server.close();

            this.port = port;
            this.createServer();
        }
    }

    /* Responds to a new socket with the /v2/status-like response and then closes
     * the connection */
    private handleSocket(socket: Net.Socket): void {
        const id: string = uuid.v4();
        this.openSockets[id] = socket;
        socket.on("close", () => {
            delete this.openSockets[id];
        });

        socket.on("error", (e) => {
            console.log(e);
        });

        socket.setEncoding("utf8");
        this.sendInformation(socket)
            .then(() => {
                socket.destroy();
            });
    }

    /* Generates a /v2/status-like response using the tracking server counts and player names
     * and sends it to the socket */
    private async sendInformation(socket: Net.Socket): Promise<void> {
        let version = "1.4.2.3";
        try {
            version = (await fs.promises.readFile("version.txt")).toString();
        } catch(e) {

        }
        const response: ApiResponse = {
            status: 200,
            name: this.response?.name ?? "",
            serverversion: this.response?.version ?? version,
            tshockversion: {
                Major: 4,
                Minor: 4,
                Build: 0,
                Revision: 0,
                MajorRevision: 0,
                MinorRevision: 0
            },
            port: this.response?.terrariaServerPort ?? 7777,
            playercount: 0,
            maxplayers: this.response?.maxPlayers ?? 400,
            world: this.response?.worldName ?? "Dimensions Generic",
            uptime: "0.01:27:38",
            serverpassword: this.response?.hasServerPassword ?? false,
            players: [

            ]
        };

        const playerNames = Object.keys(this.globalTracking.names);

        // This is compatible with terraria-servers.com.
        // When they fix their usage of old rest, this
        // should be updated
        response.players = playerNames.join(", ");

        // New REST version
        // response.players = playerNames;

        response.playercount = playerNames.length;
        socket.write("HTTP/1.1 200 OK\nAccess-Control-Allow-Origin: *\nContent-Type:application/json; charset=utf-8\n\n"+JSON.stringify(response));
    }
}

export default RestApi;
