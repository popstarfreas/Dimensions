import Player from 'dimensions/player';
import TerrariaServer from 'dimensions/terrariaserver';
import * as Net from 'net';
import { ConfigOptions } from 'dimensions/configloader';
import PacketTypes from 'dimensions/packettypes';
import ClientPacketHandler from 'dimensions/clientpackethandler';
import RoutingServer from 'dimensions/routingserver';
import GlobalHandlers from 'dimensions/globalhandlers';
import ServerDetails from 'dimensions/serverdetails';
import RoutingInformation from 'dimensions/routinginformation';
import PacketWriter from 'dimensions/packets/packetwriter';
import NetworkText from 'dimensions/packets/networktext';
import { getPacketsFromBuffer, BuffersPackets } from 'dimensions/utils';
import RawPacket from 'dimensions/packets/rawpacket';
import ChangeServerOptions from 'dimensions/changeserveroptions';
import GlobalTracking from 'dimensions/globaltracking';
import ClientState from 'dimensions/clientstate';
import Logger from 'dimensions/logger';
import ClientArgs from 'dimensions/clientargs';
import ErrorHelper from 'dimensions/errorhelper';

/**
 * This class handles switching servers and passing data of a single client
 */
class Client {
  public ID: number;
  public options: ConfigOptions;
  public servers: { [id: string]: RoutingServer };
  public socket: Net.Socket;
  public ip: string;
  public player: Player;
  public globalHandlers: GlobalHandlers;
  public server: TerrariaServer;
  public connected: boolean;
  public state: ClientState;
  private initialConnectionAlreadyCreated: boolean;
  public ingame: boolean;
  public UUID: string;
  public waitingCharacterRestore: boolean;
  public wasKicked: boolean;
  public routingInformation: RoutingInformation | null;
  public countIncremented: boolean;
  public serversDetails: { [id: string]: ServerDetails };
  public preventSpawnOnJoin: boolean;
  public packetQueue: Buffer[];
  public logging: Logger;
  private globalTracking: GlobalTracking;
  private bufferPacket: Buffer;

  ServerHandleError: (error: Error) => void;
  ServerHandleData: (data: Buffer) => void;
  ServerHandleClose: () => void;

  constructor(args: ClientArgs) {
    this.ID = args.id;

    // Options from the config
    this.options = args.options;

    // Tracking Information
    this.globalTracking = args.globalTracking;

    // TerrariaServer information available for connecting to
    this.servers = args.servers;

    // The socket connection to the net server associated with this client
    this.socket = args.socket;

    // The unformatted ip address for the current socket connection to the net server
    this.ip = args.socket.remoteAddress as string;

    // This clients player object which can be used
    // for storing inventory and other player information
    this.player = new Player(this);

    // Global Handlers object whose contents may be updated (reloaded/refreshed)
    this.globalHandlers = args. globalHandlers;

    // For logging errors/info
    this.logging = args.logging;

    // TerrariaServer socket connection and packet handler
    this.server = new TerrariaServer(new Net.Socket(), this);
    this.server.ip = args.server.serverIP;
    this.server.port = args.server.serverPort;
    this.server.name = args.server.name;
    this.server.isVanilla = args.server.isVanilla;

    // Current connection state to TerrariaServer
    this.connected = false;

    // Connection State
    // 0 => Fresh Connection
    // 1 => Finished Sending Inventory
    // 2 => Connection to new server established (extra packet help required because of the actual clients state
    //      being incapable of sending certain packets)
    // 3 => Packet Help sent  Get Section/Request Sync [8] packet in response to world info [7], now waiting on Update Shield Strengths [101]
    // 4 => Spawned on server / Completed Server switch
    // 5 => Disconnected from a terraria server
    this.state = ClientState.FreshConnection;

    // Incomplete packet from last data received. This is used because all packets are inspected
    this.bufferPacket = Buffer.allocUnsafe(0);

    // This is used to make the first connection to a TerrariaServer after receiving data
    this.initialConnectionAlreadyCreated = false;

    // A boolean of whether the current client has made it in-game (they can see minimap, world, tiles, their inventory)
    this.ingame = false;

    // UUID of client
    this.UUID = "";

    this.waitingCharacterRestore = false;

    // A boolean indicating that the socket was closed because the client was booted from the TerrariaServers
    // This is set to false again after the close handler has been run
    this.wasKicked = false;

    // Information to the server about a type of join (gamemode)
    this.routingInformation = null;

    // Whether or not count was incremented
    // this will be turned off when we minus from count
    this.countIncremented = false;

    // The counts of all TerrariaServers available
    this.serversDetails = args.serversDetails;

    this.preventSpawnOnJoin = false;

    this.ServerHandleError = this.server.handleError.bind(this.server);
    this.ServerHandleData = this.server.handleData.bind(this.server);
    this.ServerHandleClose = this.server.handleClose.bind(this.server);

    // Packets that have been queued as they were sent at the wrong time
    // are stored in the packetQueue
    this.packetQueue = [];
  }

  /**
   * Gets the packet handler for this client
   * 
   * @return The packet handler 
   */
  public getPacketHandler(): ClientPacketHandler {
    return this.globalHandlers.clientPacketHandler;
  }

  /**
   * Sends the disconnect packet and then closes the socket
   *
   * @param reason The reason for the disconnect
   */
  public disconnect(reason: string) {
    const networkText = new NetworkText(0, reason);
    var disconnect = new PacketWriter()
      .setType(PacketTypes.Disconnect)
      .packNetworkText(networkText)
      .data;

    this.socket.write(disconnect);
    this.socket.pause();

    // Don't disconnect instantly otherwise it will show 'Lost Connection' on client
    setTimeout(() => {
      this.socket.destroy();
    }, 500);
  }

  /**
   * Updates the stored name for this client. Will disconnect them if they try
   * to use a name already in use.
   * 
   * @param name The name they are wanting to use
   */
  public setName(name: string): void {
    if (this.player.name === name) {
      return;
    }

    // Only change when the name is not in use by another client
    if (this.globalTracking.names[name]) {
      this.disconnect(`Someone called ${name} is already on the server.`)
      return;
    }

    if (name.length < 2 || name.length > 20) {
      this.disconnect("A character name must be between (inclusive) 2 to 20 characters long.");
      return;
    }

    if (this.player.name !== "") {
      delete this.globalTracking.names[this.player.name];
    }

    this.player.name = name;

    if (name !== "") {
      this.globalTracking.names[name] = true;
    }
  }

  public getName(): string {
    return this.player.name;
  }

  public handleDataSend(encodedData: Buffer): void {
    try {
      // Add Buffer Packet (incomplete packet from last data)
      // to the new data
      let bufferPacket = this.bufferPacket;
      let entireData = Buffer.concat([bufferPacket, encodedData]);

      // Get the individual packets from the data
      let entireDataInfo: BuffersPackets = getPacketsFromBuffer(entireData);

      // Update Buffer Packet using the new incomplete packet (if any)
      this.bufferPacket = entireDataInfo.bufferPacket;

      let packets: RawPacket[] = entireDataInfo.packets;

      // The packets are only handled if the client has already connected
      // to a server for the first time
      if (this.initialConnectionAlreadyCreated) {
        let allowedData: Buffer[] = [];
        packets.forEach((packet: RawPacket) => {
          const buf = this.getPacketHandler().handlePacket(this, packet);
          if (buf !== null) {
            allowedData.push(buf);
          }
        });

        // Send allowedData to the server if the client is connected to one
        if (allowedData.length > 0 && this.connected) {
          if (this.server.socket) {
            for (const buf of allowedData) {
              this.server.socket.write(buf);
            }
          } else {
            this.sendChatMessage("Are you even connected?", "ff0000");
          }
        }
      } else {
        // Connect to a server for the first time in this session
        this.initialConnectionAlreadyCreated = true;
        this.player.allowedCharacterChange = true;
        this.player.allowedLifeChange = true;
        this.player.allowedManaChange = true;
        this.player.allowedNameChange = true;

        this.server.socket.on('data', this.ServerHandleData);
        this.server.socket.on('close', this.ServerHandleClose);
        this.server.socket.on('error', this.ServerHandleError);

        this.server.socket.connect(this.server.port, this.server.ip, () => {
          this.countIncremented = true;
          this.serversDetails[this.server.name].clientCount++;
          this.serversDetails[this.server.name].failedConnAttempts = 0;
          this.connected = true;

          // In order to allow inspection of first packet regardless of fake version
          let allowedData: Buffer[] = [];
          packets.forEach((packet: RawPacket) => {
            const buf = this.getPacketHandler().handlePacket(this, packet);
            if (buf !== null) {
              allowedData.push(buf);
            }
          });

          // Write the data the client sent us to the now connected server
          if (this.options.fakeVersion.enabled) {
            const verText = "Terraria" + this.options.fakeVersion.terrariaVersion;
            let packet = new PacketWriter()
              .setType(1)
              .packString(verText)
              .data;
            this.server.socket.write(packet);
          } else {
            // Send allowedData to the server if the client is connected to one
            if (allowedData.length > 0 && this.connected) {
              if (this.server.socket) {
                for (const buf of allowedData) {
                  this.server.socket.write(buf);
                }
              } else {
                this.sendChatMessage("Are you even connected?", "ff0000");
              }
            }
          }
        });
      }
    } catch (e) {
      if (this.options.log.clientError) {
        if (this.options.log.outputToConsole) {
          console.log(`Client Handle Send Data Error: ${e}`);
        }

        this.logging.appendLine(`Client Handle Send Data Error: ${ErrorHelper.toMessage(e)}`);
      }
    }
  }

  // Useful method for sending a chat message packet to a client */
  public sendChatMessage(text: string | NetworkText, color?: string | undefined): void {
    if (this.socket.destroyed) {
      return;
    }
    
    let networkText: NetworkText;
    if (text instanceof NetworkText) {
      networkText = text;
    } else {
      networkText = new NetworkText(0, text);
    }

    if (networkText.text.length > 0) {
      if (typeof color === 'undefined') {
        color = "00ff00"
      }

      let chatMessage = new PacketWriter()
          .setType(PacketTypes.LoadNetModule)
          .packUInt16(1)
          .packByte(255)
          .packNetworkText(networkText)
          .packHex(color)
          .data;
        
      const packet = { packetType: PacketTypes.LoadNetModule, data: chatMessage };
      this.server.getPacketHandler().handlePacket(this.server, packet);
      this.socket.write(packet.data);
    }
  }

  /* Sends any queued packets from the connection phase to the server */
  public sendWaitingPackets(): void {
    if (!this.server.socket.destroyed && this.packetQueue.length > 0) {
      for (const packet of this.packetQueue) {
        this.server.socket.write(packet);
      }
      
      this.packetQueue = [];
    }
  }

  /* Handles switching from one server to another */
  public changeServer(server: RoutingServer, options?: ChangeServerOptions): void {
    let ip: string = server.serverIP;
    let port: number = server.serverPort;
    let name: string = server.name;
    let isVanilla: boolean = server.isVanilla;

    if (typeof options !== 'undefined' && typeof options.preventSpawnOnJoin !== 'undefined') {
      this.preventSpawnOnJoin = options.preventSpawnOnJoin;
    } else {
      this.preventSpawnOnJoin = false;
    }

    // Client is now not connected to a server
    this.connected = false;

    this.server.afterClosed = () => {
      // Remove data and error listeners on TerrariaServer socket
      // done AFTER being closed to avoid errors potentially cropping up unhandled
      this.server.socket.removeListener('data', this.ServerHandleData);
      this.server.socket.removeListener('error', this.ServerHandleError);

      this.server.afterClosed = null;
      // Remove close listener now that socket has been closed and event was called
      this.server.socket.removeListener('close', this.ServerHandleClose);

      // Start new socket
      this.server.socket = new Net.Socket();
      if (this.server.isSSC) {
        this.waitingCharacterRestore = true;
      } else {
        // Only allow updates to visuals if coming from non-ssc
        this.player.allowedCharacterChange = true;
        this.player.allowedLifeChange = true;
        this.player.allowedManaChange = true;
      }
      this.server.reset();
      this.state = ClientState.FreshConnection;

      //console.log("Connecting to " + ip + ":" + port);

      // Update server information
      this.server.ip = ip;
      this.server.port = port;
      this.server.name = name;
      this.server.isVanilla = isVanilla;

      // Allow name change during this stage
      this.player.allowedNameChange = true;

      // Prevent Item problem
      const stoned = {
        data: new PacketWriter()
          .setType(PacketTypes.AddPlayerBuff)
          .packByte(this.player.id)
          .packUInt16(156)
          .packInt32(300)
          .data,
        packetType: PacketTypes.AddPlayerBuff,
      };
      
      if (!this.server.getPacketHandler().handlePacket(this.server, stoned)) {
        this.send(stoned.data);
      }

      const webbed = {
        data: new PacketWriter()
          .setType(PacketTypes.AddPlayerBuff)
          .packByte(this.player.id)
          .packUInt16(149)
          .packInt32(300)
          .data,
        packetType: PacketTypes.AddPlayerBuff,
      };

      if (!this.server.getPacketHandler().handlePacket(this.server, webbed)) {
        this.send(webbed.data);
      }

      this.server.socket.on('data', this.ServerHandleData);
      this.server.socket.on('close', this.ServerHandleClose);
      this.server.socket.on('error', this.ServerHandleError);

      // Create connection
      this.server.socket.connect(port, ip, () => {
        if (this.options.log.tServerConnect) {
          if (this.options.log.outputToConsole) {
            console.log(`[${process.pid}] TerrariaServer Socket Connection [${ip}:${port}]`);
          }

          this.logging.appendLine(`[${process.pid}] TerrariaServer Socket Connection [${ip}:${port}]`);
        }

        // Increment server count
        this.countIncremented = true;
        if (!this.serversDetails[this.server.name]) {
          this.serversDetails[this.server.name] = { clientCount: 0, failedConnAttempts: 0, disabled: false, disabledTimeout: null };
        }
        this.serversDetails[this.server.name].clientCount++;
        this.serversDetails[this.server.name].failedConnAttempts = 0;

        const verText = `Terraria${this.options.currentTerrariaVersion}`;
        var connectPacket = new PacketWriter()
          .setType(1)
          .packString(verText)
          .data;

        // Construct Packet object to be handled by any handlers first
        let packet: RawPacket = {
          packetType: PacketTypes.ConnectRequest,
          data: connectPacket
        };
        let allowedData = this.server.getPacketHandler().handlePacket(this.server, packet);

        if (allowedData !== null) {
          this.server.socket.write(packet.data);
        }

        if (typeof options !== 'undefined' && typeof options.routingInformation !== 'undefined') {
          this.routingInformation = options.routingInformation;
        }
        this.state = ClientState.ConnectionSwitchEstablished;
        this.connected = true;
      });
    };

    // Close the TerrariaServer socket completely
    if (!this.server.socket.destroyed) {
      this.server.socket.destroy();
    } else {
      this.server.afterClosed(this);
    }
  }

  /**
   * Sends data if the socket is open
   * @param buf 
   */
  public send(buf: Buffer): void {
    if (!this.socket.destroyed) {
      this.socket.write(buf);
    }
  }

  public handleError(err: Error): void {
    //console.log("Client Socket Error: " + err);
  }

  public handleClose(): void {
    //console.log("Client Socket Closed.");
    if (!this.server.socket.destroyed) {
      this.server.afterClosed = null;
      this.server.socket.destroy();
    }

    if (this.getName() !== "") {
      delete this.globalTracking.names[this.getName()];
    }
  }
}

export default Client;
