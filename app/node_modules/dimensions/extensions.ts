import {LogOptions} from "dimensions/configloader";
import Extension from "dimensions/extension";
import ListenServer from "dimensions/listenserver";
import Logger from "dimensions/logger";
import {requireNoCache} from "dimensions/utils";
import * as glob from "glob";
import * as path from "path";
import { Dictionary } from "dimensions/dictionary";
import ErrorHelper from 'dimensions/errorhelper';

type ExtensionModule = { default: { new(): Extension } }
/**
 * Require a js file, if it exists, that defines the extensions to load.
 * This. is most useful when using a bundler to package an install of dimensions into a small js file.
 * Note however that this means they will NOT be loaded again when using the CLI to do a reloadplugins.
 */
let extensionModules: Array<ExtensionModule> | null = null;
try {
    const possibleExtensionModules = require("../../extensions");
    if (!Array.isArray(possibleExtensionModules)) {
        console.log("WARNING: Extensions file must export an array to be valid.");
    } else {
        extensionModules = possibleExtensionModules;
    }
} catch(e) {
    extensionModules = null;
}

class Extensions {
    public static folder: string = "./extensions";

    public static loadExtensions(extensionsList: Dictionary<Extension>, listenServers: { [name: string]: ListenServer }, options: LogOptions, logging: Logger, storageMap: Map<string, any>) {
        try {
            if (extensionModules === null) {
                logging.appendLine("INFO: Dynamically loading extensions.");
                extensionModules = glob.sync(`${this.folder}/**/index.js`).map((file) => {
                    return requireNoCache(path.resolve(file), require) as ExtensionModule;
                }).filter(extensionModule => typeof extensionModule.default !== "undefined");
            }

            extensionModules.forEach((extensionModule) => {
                const extension: Extension = new (extensionModule.default)();
                const storage = storageMap.get(extension.name);
                if (extension.load && typeof storage !== "undefined") {
                    extension.load(storage);
                    storageMap.delete(extension.name);
                }

                extensionsList[extension.name] = extension;
                if (typeof extension.setListenServers === "function") {
                    extension.setListenServers(listenServers);
                }

                if (options.extensionLoad) {
                    if (options.outputToConsole) {
                        console.log(`\u001b[36m[Extension] ${extension.name} ${extension.version} loaded.\u001b[37m`);
                    }

                    logging.appendLine(`[Extension] ${extension.name} ${extension.version} loaded.`);
                }
            });
        } catch(e) {
            if (options.outputToConsole) {
                console.log("Failed to load extensions. Error: ");
                console.log(e);
            }
            
            logging.appendLine(`Failed to load extensions. Error: `);
            logging.appendLine(ErrorHelper.toMessage(e));
        }
    }
}

export default Extensions;