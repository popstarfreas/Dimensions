import { textToBuffer } from 'dimensions/utils';
import * as utf8 from 'utf8';
import NetworkText from 'dimensions/packets/networktext';
import Writer from 'dimensions/packets/writer';

class BufferWriter implements Writer {
    protected _buffer: Buffer;
    protected _offset: number = 0;

    constructor(size: number) {
        this._buffer = Buffer.allocUnsafe(size);
    }

    public changeOffset(offset: number) {
        this._offset = offset;
    }

    public packInt16(int16: number) {
        this._buffer.writeInt16LE(int16, this._offset);
        this._offset += 2;
        return this;
    }

    public packUInt16(uint16: number) {
        this._buffer.writeUInt16LE(uint16, this._offset);
        this._offset += 2;
        return this;
    }

    public packInt32(int32: number) {
        this._buffer.writeInt32LE(int32, this._offset);
        this._offset += 4;
        return this;
    }

    public packUInt32(uint32: number) {
        this._buffer.writeUInt32LE(uint32, this._offset);
        this._offset += 4;
        return this;
    }

    public packUInt64(uint64: number) {
        this.packUInt32(uint64 >> 8);
        this.packUInt32(uint64 & 0x00ff);
        return this;
    }

    public packSingle(single: number) {
        this._buffer.writeFloatLE(single, this._offset);
        this._offset += 4;
        return this;
    }

    public packByte(byte: number) {
        if (byte < 0) byte = -byte;
        this._buffer.writeUInt8(byte, this._offset);
        this._offset += 1;
        return this;
    }

    public packSByte(byte: number) {
        this._buffer.writeInt8(byte, this._offset);
        this._offset += 1;
        return this;
    }

    public packBytes(bytes: number[]) {
        for (const byte of bytes) {
            this.packByte(byte);
        }

        return this;
    }

    public packHex(hex: string) {
        const buf = Buffer.from(hex, "hex");
        buf.copy(this._buffer, this._offset, 0);
        this._offset += buf.length;
        return this;
    }

    public packBuffer(buffer: Buffer) {
        buffer.copy(this._buffer, this._offset, 0);
        this._offset += buffer.length;
        return this;
    }

    public packString(str: string) {
        const packedStr = textToBuffer(utf8.encode(str));
        const strLen = packedStr.length;

        if (strLen >= 128) {
            this.packByte((strLen % 128) + 128);
            this.packByte(Math.floor(strLen / 128));
        } else {
            this.packByte(strLen);
        }

        this.packBuffer(packedStr);
        return this;
    }

    public packColor(color: {R:number;G:number;B:number}) {
        this.packByte(color.R);
        this.packByte(color.G);
        this.packByte(color.B);
        return this;
    }

    public packNetworkText(networkText: NetworkText) {
        this.packByte(networkText.mode);
        this.packString(networkText.text);

        if (networkText.substitutionList) {
            this.packByte(networkText.substitutionList.length);
            for (let i = 0; i < networkText.substitutionList.length; i++)
            {
                this.packNetworkText(networkText.substitutionList[i]);
            }
        } else if (networkText.mode != 0) {
            this.packByte(0);
        }

        return this;
    }

    public get data() {
        return this._buffer;
    }

    public get slicedData() {
        return this._buffer.slice(0, this._offset);
    }
}

export default BufferWriter;
