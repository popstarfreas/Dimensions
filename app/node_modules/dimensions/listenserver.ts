import * as Net from 'net';
import RawPacket from 'dimensions/packets/rawpacket';
import { getProperIP } from 'dimensions/utils';
import Client from 'dimensions/client';
import ClientArgs from 'dimensions/clientargs';
import ServerDetails from 'dimensions/serverdetails';
import GlobalHandlers from 'dimensions/globalhandlers';
import { ConfigListenServer, ConfigOptions } from 'dimensions/configloader';
import RoutingServer from 'dimensions/routingserver';
import Blacklist from 'dimensions/blacklist';
import PacketTypes from 'dimensions/packettypes';
import PacketWriter from 'dimensions/packets/packetwriter';
import GlobalTracking from 'dimensions/globaltracking';
import ListenServerArgs from 'dimensions/listenserverargs';
import NetworkText from 'dimensions/packets/networktext';
import StringUtils from 'dimensions/stringutils';
import ErrorHelper from 'dimensions/errorhelper';
import BlacklistCheckClient from 'dimensions/blacklistcheckclient';
import * as winston from 'winston';

/**
 * Listens on a specified port and routes users balancing amounts between routing servers it handles
 */
export class ListenServer {
  public clients: Client[];
  /** The clients that are currently being checked for whether they are blacklisted */
  public checkingClients: BlacklistCheckClient[];
  public servers: { [id: string]: RoutingServer };
  private idCounter: number;
  private options: ConfigOptions;
  private port: number;
  private routingServers: RoutingServer[];
  private serversDetails: { [id: string]: ServerDetails };
  private globalHandlers: GlobalHandlers;
  private server: Net.Server;
  private globalTracking: GlobalTracking;
  private logging: winston.Logger;
  private blacklist?: Blacklist;
  private connectionsTracker: Map<string, number>;
  private connectRateTracker: Map<string, number>;
  private limiterInterval: NodeJS.Timer | null = null;

  ServerHandleError: (error: Error) => void;
  ServerHandleStart: () => void;

  constructor(args: ListenServerArgs) {
    this.idCounter = 0;
    this.clients = [];
    this.checkingClients = [];
    this.servers = args.servers;
    this.options = args.options;
    this.port = args.info.listenPort;
    this.routingServers = args.info.routingServers;
    this.serversDetails = args.serversDetails;
    this.globalHandlers = args.globalHandlers;
    this.globalTracking = args.globalTracking;
    this.logging = args.logging;
    this.blacklist = args.blacklist;
    this.connectionsTracker = args.connectionsTracker;
    this.connectRateTracker = args.connectRateTracker;

    for (var i = 0; i < this.routingServers.length; i++) {
      this.serversDetails[this.routingServers[i].name] = {
        clientCount: 0,
        disabled: false,
        disabledTimeout: null,
        failedConnAttempts: 0
      };
    }


    this.ServerHandleError = this.handleError.bind(this);
    this.ServerHandleStart = this.handleStart.bind(this);

    // Listen Server
    this.server = Net.createServer();
    this.server.on('connection', (socket) => {
      this.handleSocket(socket)
        .catch((e) => {
          if (this.options.log.clientError) {
            this.logging.error(`Socket Error: ${ErrorHelper.toMessage(e)}`);
          }
        });
    });
    this.server.listen(this.port, this.ServerHandleStart);
    this.server.on('error', this.ServerHandleError);

    if (this.options.connectionRateLimit.enabled) {
      this.startConnectionRateLimitTimer();
    }
  }

  private startConnectionRateLimitTimer() {
    this.limiterInterval = setInterval(() => {
      this.connectRateTracker.clear();
    }, 1000);
  }

  /**
   * Finds server with lowest client count
   *
   * @return Either a found routing server or null if one was not found
   */
  private chooseServer(): RoutingServer | null {
    let chosenServer: RoutingServer | null = null;
    let currentClientCount: number | null = null;
    let details: ServerDetails;
    for (let i: number = 0; i < this.routingServers.length; i++) {
      details = this.serversDetails[this.routingServers[i].name];

      // Even if the server has been disabled, if we have no current choice, we must use it
      if (!details.disabled || currentClientCount === null) {
        // Favour either lower player count or non-disability
        if (currentClientCount === null || chosenServer === null || details.clientCount < currentClientCount || this.serversDetails[chosenServer.name].disabled) {
          chosenServer = this.routingServers[i];
          currentClientCount = details.clientCount;
        }
      }
    }

    return chosenServer;
  }

  /**
   * Replaces the current blacklist with a new instance
   */
  public loadNewBlacklist(blacklist: Blacklist) {
    this.blacklist = blacklist;
  }

  /**
   * Updates this listen server with its new ownership of routing servers
   *
   * @param info The server configuration containing the routing servers for this listen server
   */
  public updateInfo(info: ConfigListenServer): void {
    this.port = info.listenPort;
    this.routingServers = info.routingServers;

    // Reset disabled and failedConnAttempts but only
    // reset counts if it didn't already exist as a server
    let details;
    for (let i = 0; i < this.routingServers.length; i++) {
      if (this.serversDetails[this.routingServers[i].name]) {
        details = this.serversDetails[this.routingServers[i].name]
        details.disabled = false;
        details.failedConnAttempts = 0;
      } else {
        this.serversDetails[this.routingServers[i].name] = {
          clientCount: 0,
          disabled: false,
          disabledTimeout: null,
          failedConnAttempts: 0
        };
      }
    }
  }

  /**
   * Destroys all client sockets connected, removing any listeners and resets counts for any servers
   */
  public shutdown(): void {
    this.logging.info(`Server on ${this.port} is now shutting down.`);
    for (let i: number = 0; i < this.clients.length; i++) {
      this.clients[i].server.socket.removeListener('data', this.clients[i].ServerHandleData);
      this.clients[i].server.socket.removeListener('error', this.clients[i].ServerHandleError);
      this.clients[i].server.socket.removeListener('close', this.clients[i].ServerHandleClose);
      this.clients[i].disconnect(this.options.language.phrases.close);
    }
    this.clients = [];
    this.server.removeListener('error', this.ServerHandleError);
    this.server.close();

    // Reset counts
    let details: ServerDetails;
    for (var i = 0; i < this.routingServers.length; i++) {
      details = this.serversDetails[this.routingServers[i].name];
      details.clientCount = 0;
    }

    if (this.limiterInterval !== null) {
      clearInterval(this.limiterInterval);
    }
  }

  /**
   * Logs that the server was started
   */
  private handleStart(): void {
    this.logging.info(`Server on ${this.port} started.`);
  }

  /**
   * Sends the client the disconnect packet and then drops the connection
   *
   * @param socket The socket to disconnect
   * @param reason The reason to disconnect the client
   */
  private disconnectClient(socket: Net.Socket, reason: string): void {
    let kickPacket = new PacketWriter()
      .setType(PacketTypes.Disconnect)
      .packNetworkText(new NetworkText(0, reason))
      .data;

    if (!socket.destroyed) {
      socket.write(kickPacket);

      // Allow time for client to receive and process kick packet
      setTimeout(() => {
        socket.destroy();
      }, 1000);
    }
  }

  /**
   * Decrements the number of connections in the tracker for a socket's remote address
   *
   * @param socket The socket that is being disconnected
   */
  private decrementConnectionTracker(ip: string): void {
    if (this.options.connectionLimit.enabled) {
      const count = this.connectionsTracker.get(ip);
      if (typeof count !== "undefined") {
        if (count === 1) {
          this.connectionsTracker.delete(ip);
        } else {
          this.connectionsTracker.set(ip, count - 1);
        }
      }
    }
  }

  /**
   * Gets a server to connect to for a new socket connection, sets up the appropriate handlers
   * and checks if their IP is blacklisted
   *
   * @param socket The socket of a new client
   */
  private async handleSocket(socket: Net.Socket): Promise<void> {
    if ((this.options.connectionLimit.enabled && this.enforceConnectionLimit(socket))
      || this.options.connectionRateLimit.enabled && this.enforceConnectionRateLimit(socket)) {
      socket.removeAllListeners();
      return;
    }

    for (const extension of Object.values(this.globalHandlers.extensions)) {
      if (extension.socketConnectPreHandler) {
        const handled = await extension.socketConnectPreHandler(socket);
        if (handled) {
          return;
        }
      }
    }

    this.setupNewSocket(socket);

    for (const extension of Object.values(this.globalHandlers.extensions)) {
      if (extension.socketConnectPostHandler) {
        extension.socketConnectPostHandler(socket);
      }
    }
  }

  private enforceConnectionLimit(socket: Net.Socket): boolean {
    let connectionDropped = false;
    const ip = socket.remoteAddress;
    if (typeof ip === "undefined") {
      return connectionDropped;
    }

    const counter = this.connectionsTracker.get(ip);
    if (typeof counter !== "undefined") {
      if (counter + 1 > this.options.connectionLimit.connectionLimitPerIP) {
        this.connectionsTracker.set(ip, counter + 1);
        this.disconnectClient(socket, StringUtils.format(this.options.connectionLimit.kickReason, this.options.connectionLimit.connectionLimitPerIP));
        connectionDropped = true;
      } else {
        this.connectionsTracker.set(ip, counter + 1);
      }
    } else {
      this.connectionsTracker.set(ip, 1);
    }

    return connectionDropped;
  }

  private enforceConnectionRateLimit(socket: Net.Socket): boolean {
    let connectionDropped = false;
    const ip = socket.remoteAddress;
    if (typeof ip === "undefined") {
      return connectionDropped;
    }
    const count = this.connectRateTracker.get(ip);
    if (typeof count !== "undefined") {
      if (count + 1 > this.options.connectionRateLimit.connectionRateLimitPerIP) {
        this.connectRateTracker.set(ip, count + 1);
        socket.destroy();
        connectionDropped = true;
      } else {
        this.connectRateTracker.set(ip, count + 1);
      }
    } else {
      this.connectRateTracker.set(ip, 1);
    }

    return connectionDropped;
  }

  /**
   * Checks there is a server available and then sets up listeners and a client object for
   * the socket. Also checking if the ip address of this socket is blacklisted.
   */
  private async setupNewSocket(socket: Net.Socket): Promise<void> {
    let chosenServer: RoutingServer | null = this.chooseServer();
    if (chosenServer === null) {
      this.logging.warn(`No servers available for ListenServer[Port: ${this.port}]`);
      socket.destroy();
      return;
    }

    // Try using no delay (no buffering of data); maybe set to config option
    if (this.options.socketNoDelay) {
      socket.setNoDelay(true);
    }

    let clientArgs: ClientArgs = {
      id: this.idCounter++,
      socket: socket,
      server: chosenServer,
      serversDetails: this.serversDetails,
      globalHandlers: this.globalHandlers,
      servers: this.servers,
      options: this.options,
      globalTracking: this.globalTracking,
      logging: this.logging
    };

    // When the blacklist is enabled, clients must first send their initial data
    // and then get checked before they are allowed to connect to a server
    if (this.options.blacklist.enabled && this.blacklist) {
      const configuration = this.options.blacklist;
      this.sendCheckingIp(clientArgs);
      let client = new BlacklistCheckClient({
        blacklist: this.blacklist,
        clientArgs,
      });

      client.setupCallbacks({
        clientAcceptedCb: (packetsReceived: RawPacket[]) => {
          const index = this.checkingClients.indexOf(client);
          if (index > -1) {
            this.checkingClients.splice(index, 1);
          }
          this.setupNewClient(clientArgs, packetsReceived);
        },
        clientBlacklistedCb: () => {
          const index = this.checkingClients.indexOf(client);
          if (index > -1) {
            this.checkingClients.splice(index, 1);
          }
          this.kickBlacklisted(clientArgs);
        },
        errorCheckingBlacklistCb: (packetsReceived: RawPacket[], e: Error) => {
          this.logging.error(`Error checking blacklist: ${ErrorHelper.toMessage(e)}`);
          if (configuration.errorPolicy === "DenyJoining") {
            const index = this.checkingClients.indexOf(client);
            if (index > -1) {
              this.checkingClients.splice(index, 1);
            }
            this.disconnectClient(socket, this.options.language.phrases.blacklistCheckError);
          } else {
            this.setupNewClient(clientArgs, packetsReceived);
          }
        },
        packetErrorCheckingBlacklistCb: (e: Error) => {
          this.logging.error(`Packet error checking blacklist: ${ErrorHelper.toMessage(e)}`);
          const index = this.checkingClients.indexOf(client);
          if (index > -1) {
            this.checkingClients.splice(index, 1);
          }
          this.disconnectClient(socket, this.options.language.phrases.blacklistCheckError);
        },
        disconnectCb: () => {
          const index = this.checkingClients.indexOf(client);
          if (index > -1) {
            this.checkingClients.splice(index, 1);
          }
          const ip = clientArgs.socket.remoteAddress;
          if (typeof ip !== "undefined") {
            this.decrementConnectionTracker(ip);
          }
        }
      });
      this.checkingClients.push(client);
    } else {
      this.setupNewClient(clientArgs, []);
    }
  }

  private setupNewClient(clientArgs: ClientArgs, packetsAlreadyReceived: RawPacket[]): Client {
    let client = new Client(clientArgs);
    this.clients.push(client);

    if (this.options.log.clientConnect) {
      this.logging.info(`[Client: ${getProperIP(client.socket.remoteAddress)} connected [${clientArgs.server.name}: ${this.serversDetails[clientArgs.server.name].clientCount + 1}]`);
    }

    this.hookSocketError(client.socket, client);
    this.hookSocketTimeout(client.socket, client);
    this.hookSocketClose(client.socket, client);

    this.hookSocketData(client.socket, client);
    client.handleDataSend(Buffer.concat(packetsAlreadyReceived.map((packet) => packet.data)));
    return client;
  }

  /**
   * Checks the blacklist to see if the ip is blacklisted, and will disconnect the socket if they are
   *
   * @param client The client to check the information against the blacklist
   * @return Whether or not the ip is blacklisted
   */
  private kickBlacklisted(client: ClientArgs): void {
    this.disconnectClient(client.socket, this.options.language.phrases.blacklisted);

    if (this.options.log.clientBlocked) {
      this.logging.info(`${process.pid}] Client: ${getProperIP(client.socket.remoteAddress)} was blocked from joining.`);
    }
  }

  /**
   * Tells the client that its information is being checked
   *
   * @param client The client whose information is being checked
   */
  private sendCheckingIp(client: ClientArgs): void {
    const msg = "Checking access...";
    let statusPacket = new PacketWriter()
      .setType(PacketTypes.Status)
      .packInt32(1)
      .packNetworkText(new NetworkText(0, msg))
      .packByte(0)
      .data;

    client.socket.write(statusPacket);
  }

  /**
   * Hook the socket error and pass it into the client object
   *
   * @param socket The socket of the client to listen for errors on
   * @param client The client object associated with the socket
   */
  private hookSocketError(socket: Net.Socket, client: Client): void {
    socket.once('error', (e: Error) => {
      try {
        client.handleError(e);
      } catch (e) {
        if (this.options.log.clientError) {
          this.logging.error(`handleError Error: ${ErrorHelper.toMessage(e)}`)
        }
      }
    });
  }

  /**
   *  Simply destroys any sockets that have triggered the timeout
   *
   * @param socket The socket of the client to listen for timeouts on
   * @param client The client object associated with the socket
   */
  private hookSocketTimeout(socket: Net.Socket, client: Client): void {
    socket.once('timeout', () => {
      if (this.options.log.clientTimeouts) {
        this.logging.warn(`Socket Timeout: ${client.getName()} ${client.ID}`);
      }
      socket.destroy();
    });
  }

  private extensionSocketClosePreHandlers(socket: Net.Socket, client: Client): boolean {
    try {
      for (const extension of Object.values(this.globalHandlers.extensions)) {
        if (extension.socketClosePreHandler) {
          const handled = extension.socketClosePreHandler(socket, client);
          if (handled) {
            return true;
          }
        }
      }
    } catch (e) {
      if (this.options.log.extensionError) {
        const logMessage = `[${process.pid}] Extension Disconnect Pre Handler Error: ${ErrorHelper.toMessage(e)}`;
        this.logging.info(logMessage);
      }
    }

    return false;
  }

  private extensionSocketClosePostHandlers(socket: Net.Socket, client: Client) {
    try {
      for (const extension of Object.values(this.globalHandlers.extensions)) {
        if (extension.socketClosePostHandler) {
          extension.socketClosePostHandler(socket, client);
        }
      }
    } catch (e) {
      if (this.options.log.extensionError) {
        const logMessage = `[${process.pid}] Extension Disconnect Post Handler Error: ${ErrorHelper.toMessage(e)}`;
        this.logging.info(logMessage);
      }
    }
  }

  /**
   * Hook the socket close and pass it into the client object
   *
   * @param socket The socket of the client to listen for closing on
   * @param client The client object associated with the socket
   */
  private hookSocketClose(socket: Net.Socket, client: Client): void {
    socket.once('close', () => {
      if (this.extensionSocketClosePreHandlers(socket, client)) {
        return;
      }

      try {
        const ip = socket.remoteAddress;
        if (typeof ip !== "undefined") {
          this.decrementConnectionTracker(ip);
        }
        if (this.options.log.clientDisconnect) {
          const logMessage = `[${process.pid}] Client: ${getProperIP(ip)} disconnected ${client.server.name}: ${this.serversDetails[client.server.name].clientCount - 1}]`;
          this.logging.info(logMessage);
        }
        client.handleClose();
        for (let i: number = 0; i < this.clients.length; i++) {
          if (this.clients[i].ID === client.ID) {
            this.clients.splice(i, 1);
            break;
          }
        }
      } catch (e) {
        if (this.options.log.clientError) {
          this.logging.error(`SocketCloseEvent ERROR: ${ErrorHelper.toMessage(e)}`);
        }
      }

      socket.removeAllListeners();
      this.extensionSocketClosePostHandlers(socket, client);
    });
  }

  /**
   * Hook the socket data and pass it into the client object
   *
   * @param socket The socket of the client to listen for data on
   * @param client The client object associated with the socket
   */
  private hookSocketData(socket: Net.Socket, client: Client): void {
    socket.on('data', (data: Buffer) => {
      try {
        client.handleDataSend(data);
      } catch (e) {
        if (this.options.log.clientError) {
          this.logging.error(`HandleDataSend ERROR: ${ErrorHelper.toMessage(e)}`);
        }
      }
    });

    socket.setTimeout(this.options.socketTimeout);
  }

  /**
   * Handles when an error event occurs for this listen server
   *
   * @param error The error object containing the error information
   */
  private handleError(error: Error) {
    this.logging.error(` Server on ${this.port} encountered an error: ${ErrorHelper.toMessage(error)}.`);
  }
}

export default ListenServer;
