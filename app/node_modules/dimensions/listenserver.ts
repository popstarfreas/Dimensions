import * as Net from 'net';
import { getProperIP } from 'dimensions/utils';
import Client from 'dimensions/client';
import ClientArgs from 'dimensions/clientargs';
import ServerDetails from 'dimensions/serverdetails';
import GlobalHandlers from 'dimensions/globalhandlers';
import { ConfigListenServer, ConfigOptions } from 'dimensions/configloader';
import RoutingServer from 'dimensions/routingserver';
import Blacklist from 'dimensions/blacklist';
import PacketTypes from 'dimensions/packettypes';
import PacketWriter from 'dimensions/packets/packetwriter';
import GlobalTracking from 'dimensions/globaltracking';
import Logger from 'dimensions/logger';
import ListenServerArgs from 'dimensions/listenserverargs';
import NetworkText from 'dimensions/packets/networktext';
import StringUtils from 'dimensions/stringutils';
import ErrorHelper from 'dimensions/errorhelper';

/**
 * Listens on a specified port and routes users balancing amounts between routing servers it handles
 */
export class ListenServer {
  public clients: Client[];
  public servers: { [id: string]: RoutingServer };
  private idCounter: number;
  private options: ConfigOptions;
  private port: number;
  private routingServers: RoutingServer[];
  private serversDetails: { [id: string]: ServerDetails };
  private globalHandlers: GlobalHandlers;
  private server: Net.Server;
  private globalTracking: GlobalTracking;
  private logging: Logger;
  private blacklist: Blacklist;
  private connectionsTracker: Map<string, number>;
  private connectRateTracker: Map<string, number>;
  private limiterInterval: NodeJS.Timer | null = null;

  ServerHandleError: (error: Error) => void;
  ServerHandleStart: () => void;

  constructor(args: ListenServerArgs) {
    this.idCounter = 0;
    this.clients = [];
    this.servers = args.servers;
    this.options = args.options;
    this.port = args.info.listenPort;
    this.routingServers = args.info.routingServers;
    this.serversDetails = args.serversDetails;
    this.globalHandlers = args.globalHandlers;
    this.globalTracking = args.globalTracking;
    this.logging = args.logging;
    this.blacklist = args.blacklist;
    this.connectionsTracker = args.connectionsTracker;
    this.connectRateTracker = args.connectRateTracker;

    for (var i = 0; i < this.routingServers.length; i++) {
      this.serversDetails[this.routingServers[i].name] = {
        clientCount: 0,
        disabled: false,
        disabledTimeout: null,
        failedConnAttempts: 0
      };
    }


    this.ServerHandleError = this.handleError.bind(this);
    this.ServerHandleStart = this.handleStart.bind(this);

    // Listen Server
    this.server = Net.createServer();
    this.server.on('connection', (socket) => {
      this.handleSocket(socket)
        .catch((e) => {
          if (this.options.log.clientError) {
            if (this.options.log.outputToConsole) {
              console.log(`Socket Error: ${e}`);
            }
            this.logging.appendLine(ErrorHelper.toMessage(e));
          }
        });
    });
    this.server.listen(this.port, this.ServerHandleStart);
    this.server.on('error', this.ServerHandleError);

    if (this.options.connectionRateLimit.enabled) {
      this.startConnectionRateLimitTimer();
    }
  }

  private startConnectionRateLimitTimer() {
    this.limiterInterval = setInterval(() => {
      this.connectRateTracker.clear();
    }, 1000);
  }

  /**
   * Finds server with lowest client count
   *
   * @return Either a found routing server or null if one was not found
   */
  private chooseServer(): RoutingServer | null {
    let chosenServer: RoutingServer | null = null;
    let currentClientCount: number | null = null;
    let details: ServerDetails;
    for (let i: number = 0; i < this.routingServers.length; i++) {
      details = this.serversDetails[this.routingServers[i].name];

      // Even if the server has been disabled, if we have no current choice, we must use it
      if (!details.disabled || currentClientCount === null) {
        // Favour either lower player count or non-disability
        if (currentClientCount === null || chosenServer === null || details.clientCount < currentClientCount || this.serversDetails[chosenServer.name].disabled) {
          chosenServer = this.routingServers[i];
          currentClientCount = details.clientCount;
        }
      }
    }

    return chosenServer;
  }

  /**
   * Replaces the current blacklist with a new instance
   */
  public loadNewBlacklist(blacklist: Blacklist) {
    this.blacklist = blacklist;
  }

  /**
   * Updates this listen server with its new ownership of routing servers
   *
   * @param info The server configuration containing the routing servers for this listen server
   */
  public updateInfo(info: ConfigListenServer): void {
    this.port = info.listenPort;
    this.routingServers = info.routingServers;

    // Reset disabled and failedConnAttempts but only
    // reset counts if it didn't already exist as a server
    let details;
    for (let i = 0; i < this.routingServers.length; i++) {
      if (this.serversDetails[this.routingServers[i].name]) {
        details = this.serversDetails[this.routingServers[i].name]
        details.disabled = false;
        details.failedConnAttempts = 0;
      } else {
        this.serversDetails[this.routingServers[i].name] = {
          clientCount: 0,
          disabled: false,
          disabledTimeout: null,
          failedConnAttempts: 0
        };
      }
    }
  }

  /**
   * Destroys all client sockets connected, removing any listeners and resets counts for any servers
   */
  public shutdown(): void {
    if (this.options.log.outputToConsole) {
      console.log(`\u001b[33m[${process.pid}] Server on ${this.port} is now shutting down.\u001b[0m`);
    }

    this.logging.appendLine(`[${process.pid}] Server on ${this.port} is now shutting down.`);
    for (let i: number = 0; i < this.clients.length; i++) {
      this.clients[i].server.socket.removeListener('data', this.clients[i].ServerHandleData);
      this.clients[i].server.socket.removeListener('error', this.clients[i].ServerHandleError);
      this.clients[i].server.socket.removeListener('close', this.clients[i].ServerHandleClose);
      this.clients[i].handleClose = function () { };
      this.clients[i].socket.destroy();
    }
    this.clients = [];
    this.server.removeListener('error', this.ServerHandleError);
    this.server.close();

    // Reset counts
    let details: ServerDetails;
    for (var i = 0; i < this.routingServers.length; i++) {
      details = this.serversDetails[this.routingServers[i].name];
      details.clientCount = 0;
    }

    if (this.limiterInterval !== null) {
      clearInterval(this.limiterInterval);
    }
  }

  /**
   * Logs that the server was started
   */
  private handleStart(): void {
    if (this.options.log.outputToConsole) {
      console.log(`\u001b[32m[${process.pid}] Server on ${this.port} started.\u001b[0m`);
    }

    this.logging.appendLine(`[${process.pid}] Server on ${this.port} started.`);
  }

  /**
   * Sends the client the disconnect packet and then drops the connection
   *
   * @param socket The socket to disconnect
   * @param reason The reason to disconnect the client
   */
  private disconnectClient(socket: Net.Socket, reason: string): void {
    let kickPacket = new PacketWriter()
      .setType(PacketTypes.Disconnect)
      .packNetworkText(new NetworkText(0, reason))
      .data;

    if (!socket.destroyed) {
      socket.write(kickPacket);

        // Allow time for client to receive and process kick packet
      setTimeout(() => {
        socket.destroy();
      }, 1000);
    }
  }

  /**
   * Decrements the number of connections in the tracker for a socket's remote address
   *
   * @param socket The socket that is being disconnected
   */
  private decrementConnectionTracker(socket: Net.Socket): void {
    if (this.options.connectionLimit.enabled) {
      const ip = getProperIP(socket.remoteAddress);
      const count = typeof ip !== "undefined" ? this.connectionsTracker.get(ip) : undefined;
      if (typeof ip !== "undefined" && typeof count !== "undefined") {
        if (count === 1) {
          this.connectionsTracker.delete(ip);
        } else {
          this.connectionsTracker.set(ip, count - 1);
        }
      }
    }
  }

  /**
   * Gets a server to connect to for a new socket connection, sets up the appropriate handlers
   * and checks if their IP is blacklisted
   *
   * @param socket The socket of a new client
   */
  private async handleSocket(socket: Net.Socket): Promise<void> {
    if ((this.options.connectionLimit.enabled && this.enforceConnectionLimit(socket))
      || this.options.connectionRateLimit.enabled && this.enforceConnectionRateLimit(socket)) {
        socket.removeAllListeners();
        return;
    }

    for (const extension of Object.values(this.globalHandlers.extensions)) {
      if (extension.socketConnectPreHandler) {
        const handled = await extension.socketConnectPreHandler(socket);
        if (handled) {
          return;
        }
      }
    }

    this.setupNewSocket(socket);

    for (const extension of Object.values(this.globalHandlers.extensions)) {
      if (extension.socketConnectPostHandler) {
        extension.socketConnectPostHandler(socket);
      }
    }
  }

  private enforceConnectionLimit(socket: Net.Socket): boolean {
    let connectionDropped = false;
    const ip = getProperIP(socket.remoteAddress);
    const counter = typeof ip !== "undefined" ? this.connectionsTracker.get(ip) : undefined;
    if (typeof ip !== "undefined" && typeof counter !== "undefined") {
      if (counter + 1 > this.options.connectionLimit.connectionLimitPerIP) {
        this.disconnectClient(socket, StringUtils.format(this.options.connectionLimit.kickReason, this.options.connectionLimit.connectionLimitPerIP));
        connectionDropped = true;
      } else {
        this.connectionsTracker.set(ip, counter + 1);
      }
    } else if (typeof ip !== "undefined") {
      this.connectionsTracker.set(ip, 1);
    }

    return connectionDropped;
  }

  private enforceConnectionRateLimit(socket: Net.Socket): boolean {
    let connectionDropped = false;
    const ip = getProperIP(socket.remoteAddress);
    const count = typeof ip !== "undefined" ? this.connectRateTracker.get(ip) : undefined;
    if (typeof ip !== "undefined" && typeof count !== "undefined") {
      if (count + 1 > this.options.connectionRateLimit.connectionRateLimitPerIP) {
        socket.destroy();
        connectionDropped = true;
      } else {
        this.connectRateTracker.set(ip, count + 1);
      }
    } else if (typeof ip !== "undefined") {
      this.connectRateTracker.set(ip, 1);
    }

    return connectionDropped;
  }

  /**
   * Checks there is a server available and then sets up listeners and a client object for
   * the socket. Also checking if the ip address of this socket is blacklisted.
   */
  private async setupNewSocket(socket: Net.Socket): Promise<void> {
    let i = 0;
    let chosenServer: RoutingServer | null = this.chooseServer();
    if (chosenServer === null) {
      if (this.options.log.outputToConsole) {
        console.log(`No servers available for ListenServer[Port: ${this.port}]`)
      }

      this.logging.appendLine(`No servers available for ListenServer[Port: ${this.port}]`);
      this.decrementConnectionTracker(socket);
      socket.destroy();
      return;
    }

    // Try using no delay (no buffering of data); maybe set to config option
    if (this.options.socketNoDelay) {
      socket.setNoDelay(true);
    }

    let clientArgs: ClientArgs = {
      id: this.idCounter++,
      socket: socket,
      server: chosenServer,
      serversDetails: this.serversDetails,
      globalHandlers: this.globalHandlers,
      servers: this.servers,
      options: this.options,
      globalTracking: this.globalTracking,
      logging: this.logging
    };

    let client = new Client(clientArgs);
    this.clients.push(client);

    if (this.options.log.clientConnect) {
      if (this.options.log.outputToConsole) {
        console.log(`[${process.pid} Client: ${getProperIP(socket.remoteAddress)} connected [${chosenServer.name}: ${this.serversDetails[chosenServer.name].clientCount + 1}]`);
      }

      this.logging.appendLine(`[${process.pid} Client: ${getProperIP(socket.remoteAddress)} connected [${chosenServer.name}: ${this.serversDetails[chosenServer.name].clientCount + 1}]`);
    }

    this.hookSocketError(socket, client);
    this.hookSocketTimeout(socket, client);
    this.hookSocketClose(socket, client);

    // Check blacklist if enabled before parsing any data and thus connecting to a server
    if (this.options.blacklist.enabled) {
      await this.checkBlackList(socket);
    }

    this.hookSocketData(socket, client);
  }

  /**
   * Checks the blacklist to see if the ip is blacklisted, and will disconnect the socket if they are
   *
   * @param socket The socket to check the ip of against the blacklist
   * @return Whether or not the ip is blacklisted
   */
  private async checkBlackList(socket: Net.Socket): Promise<boolean> {
    let blocked = false;
    try {
      this.sendCheckingIp(socket);

      // Get blocked status
      blocked = await this.blacklist.checkIP(getProperIP(socket.remoteAddress as string) as string, this.options.blacklist.apiKey);
      if (blocked) {
        this.disconnectClient(socket, "Connecting using a Host Provider is not allowed.");

        if (this.options.log.clientBlocked) {
          if (this.options.log.outputToConsole) {
            console.log(`${process.pid}] Client: ${getProperIP(socket.remoteAddress)} was blocked from joining.`);
          }

          this.logging.appendLine(`${process.pid}] Client: ${getProperIP(socket.remoteAddress)} was blocked from joining.`);
        }
      }
    } catch (e) {
      if (this.options.log.outputToConsole) {
        console.log("Blacklist check failed: ");
        console.log(e);
      }

      this.logging.appendLine("Blacklist check failed: ");
      this.logging.appendLine(ErrorHelper.toMessage(e));
    }

    return blocked;
  }

  /**
   * Tells the client that its IP is being checked
   *
   * @param socket The socket of the client whose IP is being checked
   */
  private sendCheckingIp(socket: Net.Socket): void {
    const msg = "Checking IP...";
    let statusPacket = new PacketWriter()
      .setType(PacketTypes.Status)
      .packInt32(1)
      .packNetworkText(new NetworkText(0, msg))
      .packByte(0)
      .data;

    socket.write(statusPacket);
  }

  /**
   * Hook the socket error and pass it into the client object
   *
   * @param socket The socket of the client to listen for errors on
   * @param client The client object associated with the socket
   */
  private hookSocketError(socket: Net.Socket, client: Client): void {
    socket.once('error', (e: Error) => {
      try {
        client.handleError(e);
      } catch (e) {
        if (this.options.log.clientError) {
          if (this.options.log.outputToConsole) {
            console.log(`handleError ERROR: ${e}`);
          }

          this.logging.appendLine(`handleError Error: ${ErrorHelper.toMessage(e)}`)
        }
      }
    });
  }

  /**
   *  Simply destroys any sockets that have triggered the timeout
   *
   * @param socket The socket of the client to listen for timeouts on
   * @param client The client object associated with the socket
   */
  private hookSocketTimeout(socket: Net.Socket, client: Client): void {
    socket.once('timeout', () => {
      if (this.options.log.clientTimeouts) {
        if (this.options.log.outputToConsole) {
          console.log(`Socket Timeout: ${client.getName()} ${client.ID}`);
        }

        this.logging.appendLine(`Socket Timeout: ${client.getName()} ${client.ID}`);
      }
      socket.destroy();
    });
  }

  private extensionSocketClosePreHandlers(socket: Net.Socket, client: Client): boolean {
    try {
      for (const extension of Object.values(this.globalHandlers.extensions)) {
        if (extension.socketClosePreHandler) {
          const handled = extension.socketClosePreHandler(socket, client);
          if (handled) {
            return true;
          }
        }
      }
    } catch(e) {
      if (this.options.log.extensionError) {
        const logMessage = `[${process.pid}] Extension Disconnect Pre Handler Error: ${ErrorHelper.toMessage(e)}`;
        if (this.options.log.outputToConsole) {
          console.log(logMessage);
        }

        this.logging.appendLine(logMessage);
      }
    }

    return false;
  }

  private extensionSocketClosePostHandlers(socket: Net.Socket, client: Client) {
    try {
      for (const extension of Object.values(this.globalHandlers.extensions)) {
        if (extension.socketClosePostHandler) {
          extension.socketClosePostHandler(socket, client);
        }
      }
    } catch(e) {
      if (this.options.log.extensionError) {
        const logMessage = `[${process.pid}] Extension Disconnect Post Handler Error: ${ErrorHelper.toMessage(e)}`;
        if (this.options.log.outputToConsole) {
          console.log(logMessage);
        }

        this.logging.appendLine(logMessage);
      }
    }
  }

  /**
   * Hook the socket close and pass it into the client object
   *
   * @param socket The socket of the client to listen for closing on
   * @param client The client object associated with the socket
   */
  private hookSocketClose(socket: Net.Socket, client: Client): void {
    socket.once('close', () => {
      if (this.extensionSocketClosePreHandlers(socket, client)) {
        return;
      }

      try {
        this.decrementConnectionTracker(socket);
        if (this.options.log.clientDisconnect) {
          const logMessage = `[${process.pid}] Client: ${getProperIP(socket.remoteAddress)} disconnected ${client.server.name}: ${this.serversDetails[client.server.name].clientCount - 1}]`;
          if (this.options.log.outputToConsole) {
            console.log(logMessage);
          }

          this.logging.appendLine(logMessage);
        }
        client.handleClose();
        for (let i: number = 0; i < this.clients.length; i++) {
          if (this.clients[i].ID === client.ID) {
            this.clients.splice(i, 1);
            break;
          }
        }
      } catch (e) {
        if (this.options.log.clientError) {
          if (this.options.log.outputToConsole) {
            console.log(`SocketCloseEvent ERROR: ${e}`);
          }

          this.logging.appendLine(`SocketCloseEvent ERROR: ${ErrorHelper.toMessage(e)}`);
        }
      }

      socket.removeAllListeners();
      this.extensionSocketClosePostHandlers(socket, client);
    });
  }

  /**
   * Hook the socket data and pass it into the client object
   *
   * @param socket The socket of the client to listen for data on
   * @param client The client object associated with the socket
   */
  private hookSocketData(socket: Net.Socket, client: Client): void {
    socket.on('data', (data: Buffer) => {
      try {
        client.handleDataSend(data);
      } catch (e) {
        if (this.options.log.clientError) {
          if (this.options.log.outputToConsole) {
            console.log(`HandleDataSend ERROR: ${e}`);
          }

          this.logging.appendLine(`HandleDataSend ERROR: ${ErrorHelper.toMessage(e)}`);
        }
      }
    });

    socket.setTimeout(this.options.socketTimeout);
  }

  /**
   * Handles when an error event occurs for this listen server
   *
   * @param error The error object containing the error information
   */
  private handleError(error: Error) {
    if (this.options.log.outputToConsole) {
      console.log(`\u001b[31m Server on ${this.port} encountered an error: ${error}.\u001b[0m`);
    }

    this.logging.appendLine(`Server on ${this.port} encountered an error: ${error}.`);
  }
}

export default ListenServer;
